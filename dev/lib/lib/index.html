<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · PEPSKit.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="PEPSKit.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="PEPSKit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PEPSKit.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../man/intro/">Manual</a></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/master/docs/src/lib/lib.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.AbstractPEPO" href="#PEPSKit.AbstractPEPO"><code>PEPSKit.AbstractPEPO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractPEPO end</code></pre><p>Abstract supertype for a 2D projected entangled-pair operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/states/abstractpeps.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.AbstractPEPS" href="#PEPSKit.AbstractPEPS"><code>PEPSKit.AbstractPEPS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractPEPS end</code></pre><p>Abstract supertype for a 2D projected entangled-pair state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/states/abstractpeps.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.CTMRG" href="#PEPSKit.CTMRG"><code>PEPSKit.CTMRG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CTMRG(; tol=Defaults.ctmrg_tol, maxiter=Defaults.ctmrg_maxiter,
      miniter=Defaults.ctmrg_miniter, verbosity=0,
      svd_alg=TensorKit.SVD(), trscheme=FixedSpaceTruncation())</code></pre><p>Algorithm struct that represents the CTMRG algorithm for contracting infinite PEPS. Each CTMRG run is converged up to <code>tol</code> where the singular value convergence of the corners as well as the norm is checked. The maximal and minimal number of CTMRG iterations is set with <code>maxiter</code> and <code>miniter</code>. Different levels of output information are printed depending on <code>verbosity</code>, where <code>0</code> suppresses all output, <code>1</code> only prints warnings, <code>2</code> gives information at the start and end, and <code>3</code> prints information every iteration. The projectors are computed from <code>svd_alg</code> SVDs where the truncation scheme is set via  <code>trscheme</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/algorithms/ctmrg.jl#L28-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.CTMRGEnv" href="#PEPSKit.CTMRGEnv"><code>PEPSKit.CTMRGEnv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CTMRGEnv{C,T}</code></pre><p>Corner transfer-matrix environment containing unit-cell arrays of corner and edge tensors. The last two indices of the arrays correspond to the row and column indices of the unit cell, whereas the first index corresponds to the direction of the corner or edge tensor. The directions are labeled in clockwise direction, starting from the north-west corner and north edge respectively.</p><p>Given arrays of corners <code>c</code> and edges <code>t</code>, they connect to the PEPS tensors at site <code>(r, c)</code> in the unit cell as:</p><pre><code class="nohighlight hljs">   c[1,r-1,c-1]---t[1,r-1,c]----c[2,r-1,c+1]
   |              ||            |
   t[4,r,c-1]=====AA[r,c]=======t[2,r,c+1]
   |              ||            |
   c[4,r+1,c-1]---t[3,r+1,c]----c[3,r+1,c+1]</code></pre><p><strong>Fields</strong></p><ul><li><code>corners::Array{C,3}</code>: Array of corner tensors.</li><li><code>edges::Array{T,3}</code>: Array of edge tensors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/environments/ctmrgenv.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.CTMRGEnv-Union{Tuple{A}, Tuple{A, A, A}, NTuple{4, A}, NTuple{5, A}, NTuple{6, A}} where A&lt;:(AbstractMatrix{&lt;:Union{Int64, TensorKit.ElementarySpace}})" href="#PEPSKit.CTMRGEnv-Union{Tuple{A}, Tuple{A, A, A}, NTuple{4, A}, NTuple{5, A}, NTuple{6, A}} where A&lt;:(AbstractMatrix{&lt;:Union{Int64, TensorKit.ElementarySpace}})"><code>PEPSKit.CTMRGEnv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CTMRGEnv(
    [f=randn, ComplexF64], Ds_north, Ds_east::A, chis_north::A, [chis_east::A], [chis_south::A], [chis_west::A]
) where {A&lt;:AbstractMatrix{&lt;:Union{Int,ElementarySpace}}}</code></pre><p>Construct a CTMRG environment by specifying matrices of north and east virtual spaces of the corresponding <a href="#PEPSKit.InfinitePEPS"><code>InfinitePEPS</code></a> and the north, east, south and west virtual spaces of the environment. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual environment spaces for all directions are taken to be the same.</p><p>The environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site <code>(r, c)</code>, <code>chis_north[r, c]</code> corresponds to the east space of the north edge tensor, <code>chis_east[r, c]</code> corresponds to the north space of the east edge tensor, <code>chis_south[r, c]</code> corresponds to the east space of the south edge tensor, and <code>chis_west[r, c]</code> corresponds to the north space of the west edge tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/environments/ctmrgenv.jl#L57-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.CTMRGEnv-Union{Tuple{A}, Tuple{InfinitePEPS, A}, Tuple{InfinitePEPS, A, A}, Tuple{InfinitePEPS, A, A, A}, Tuple{InfinitePEPS, Vararg{A, 4}}} where A&lt;:(AbstractMatrix{&lt;:Union{Int64, TensorKit.ElementarySpace}})" href="#PEPSKit.CTMRGEnv-Union{Tuple{A}, Tuple{InfinitePEPS, A}, Tuple{InfinitePEPS, A, A}, Tuple{InfinitePEPS, A, A, A}, Tuple{InfinitePEPS, Vararg{A, 4}}} where A&lt;:(AbstractMatrix{&lt;:Union{Int64, TensorKit.ElementarySpace}})"><code>PEPSKit.CTMRGEnv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CTMRGEnv(
    [f=randn, T=ComplexF64], peps::InfinitePEPS, chis_north::A, [chis_east::A], [chis_south::A], [chis_west::A]
) where {A&lt;:AbstractMatrix{&lt;:Union{Int,ElementarySpace}}}</code></pre><p>Construct a CTMRG environment by specifying a corresponding <a href="#PEPSKit.InfinitePEPS"><code>InfinitePEPS</code></a>, and the north, east, south and west virtual spaces of the environment as matrices. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual spaces for all directions are taken to be the same.</p><p>The environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site <code>(r, c)</code>, <code>chis_north[r, c]</code> corresponds to the east space of the north edge tensor, <code>chis_east[r, c]</code> corresponds to the north space of the east edge tensor, <code>chis_south[r, c]</code> corresponds to the east space of the south edge tensor, and <code>chis_west[r, c]</code> corresponds to the north space of the west edge tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/environments/ctmrgenv.jl#L216-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{InfinitePEPS, S}, Tuple{InfinitePEPS, S, S}, Tuple{InfinitePEPS, S, S, S}, Tuple{InfinitePEPS, Vararg{S, 4}}} where S&lt;:Union{Int64, TensorKit.ElementarySpace}" href="#PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{InfinitePEPS, S}, Tuple{InfinitePEPS, S, S}, Tuple{InfinitePEPS, S, S, S}, Tuple{InfinitePEPS, Vararg{S, 4}}} where S&lt;:Union{Int64, TensorKit.ElementarySpace}"><code>PEPSKit.CTMRGEnv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CTMRGEnv(
    peps::InfinitePEPS, chi_north::S, [chi_east::S], [chi_south::S], [chi_west::S],
) where {S&lt;:Union{Int,ElementarySpace}}</code></pre><p>Construct a CTMRG environment by specifying a corresponding <a href="#PEPSKit.InfinitePEPS"><code>InfinitePEPS</code></a>, and the north, east, south and west virtual spaces of the environment. By default, the virtual spaces for all directions are taken to be the same.</p><p>The environment virtual spaces for each site correspond to virtual space of the corresponding edge tensor for each direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/environments/ctmrgenv.jl#L284-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{S, S, S}, NTuple{4, S}, NTuple{5, S}, NTuple{6, S}} where S&lt;:Union{Int64, TensorKit.ElementarySpace}" href="#PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{S, S, S}, NTuple{4, S}, NTuple{5, S}, NTuple{6, S}} where S&lt;:Union{Int64, TensorKit.ElementarySpace}"><code>PEPSKit.CTMRGEnv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CTMRGEnv(
    [f=randn, ComplexF64], D_north::S, D_south::S, chi_north::S, [chi_east::S], [chi_south::S], [chi_west::S]; unitcell::Tuple{Int,Int}=(1, 1),
) where {S&lt;:Union{Int,ElementarySpace}}</code></pre><p>Construct a CTMRG environment by specifying the north and east virtual spaces of the corresponding <a href="#PEPSKit.InfinitePEPS"><code>InfinitePEPS</code></a> and the north, east, south and west virtual spaces of the environment. The PEPS unit cell can be specified by the <code>unitcell</code> keyword argument. By default, the virtual environment spaces for all directions are taken to be the same.</p><p>The environment virtual spaces for each site correspond to virtual space of the corresponding edge tensor for each direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/environments/ctmrgenv.jl#L160-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.FixedSpaceTruncation" href="#PEPSKit.FixedSpaceTruncation"><code>PEPSKit.FixedSpaceTruncation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FixedSpaceTruncation &lt;: TensorKit.TruncationScheme</code></pre><p>CTMRG specific truncation scheme for <code>tsvd</code> which keeps the bond space on which the SVD is performed fixed. Since different environment directions and unit cell entries might have different spaces, this truncation style is different from <code>TruncationSpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/algorithms/ctmrg.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.GeomSum" href="#PEPSKit.GeomSum"><code>PEPSKit.GeomSum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GeomSum &lt;: GradMode</code></pre><p>Gradient mode for CTMRG using explicit evaluation of the geometric sum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/algorithms/peps_opt.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPO" href="#PEPSKit.InfinitePEPO"><code>PEPSKit.InfinitePEPO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct InfinitePEPO{T&lt;:PEPOTensor}</code></pre><p>Represents an infinite projected entangled-pair operator (PEPO) on a 3D cubic lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/infinitepepo.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPO-Tuple{T} where T&lt;:(TensorKit.AbstractTensorMap{S, 2, 4} where S&lt;:TensorKit.ElementarySpace)" href="#PEPSKit.InfinitePEPO-Tuple{T} where T&lt;:(TensorKit.AbstractTensorMap{S, 2, 4} where S&lt;:TensorKit.ElementarySpace)"><code>PEPSKit.InfinitePEPO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePEPO(A; unitcell=(1, 1, 1))</code></pre><p>Create an InfinitePEPO by specifying a tensor and unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/infinitepepo.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPO-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T&lt;:(TensorKit.AbstractTensorMap{S, 2, 4} where S&lt;:TensorKit.ElementarySpace)" href="#PEPSKit.InfinitePEPO-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T&lt;:(TensorKit.AbstractTensorMap{S, 2, 4} where S&lt;:TensorKit.ElementarySpace)"><code>PEPSKit.InfinitePEPO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePEPO(A::AbstractArray{T, 3})</code></pre><p>Allow users to pass in an array of tensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/infinitepepo.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPO-Union{Tuple{A}, Tuple{A, A}, Tuple{A, A, A}} where A&lt;:(AbstractArray{&lt;:TensorKit.ElementarySpace, 3})" href="#PEPSKit.InfinitePEPO-Union{Tuple{A}, Tuple{A, A}, Tuple{A, A, A}} where A&lt;:(AbstractArray{&lt;:TensorKit.ElementarySpace, 3})"><code>PEPSKit.InfinitePEPO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePEPO(f=randn, T=ComplexF64, Pspaces, Nspaces, Espaces)</code></pre><p>Allow users to pass in arrays of spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/infinitepepo.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPO-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S&lt;:TensorKit.ElementarySpace" href="#PEPSKit.InfinitePEPO-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S&lt;:TensorKit.ElementarySpace"><code>PEPSKit.InfinitePEPO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePEPO(f=randn, T=ComplexF64, Pspace, Nspace, [Espace]; unitcell=(1,1,1))</code></pre><p>Create an InfinitePEPO by specifying its spaces and unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/infinitepepo.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPS" href="#PEPSKit.InfinitePEPS"><code>PEPSKit.InfinitePEPS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct InfinitePEPS{T&lt;:PEPSTensor}</code></pre><p>Represents an infinite projected entangled-pair state on a 2D square lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/states/infinitepeps.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPS-Tuple{T} where T&lt;:(TensorKit.AbstractTensorMap{S, 1, 4} where S&lt;:TensorKit.ElementarySpace)" href="#PEPSKit.InfinitePEPS-Tuple{T} where T&lt;:(TensorKit.AbstractTensorMap{S, 1, 4} where S&lt;:TensorKit.ElementarySpace)"><code>PEPSKit.InfinitePEPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePEPS(A; unitcell=(1, 1))</code></pre><p>Create an <code>InfinitePEPS</code> by specifying a tensor and unit cell.</p><p>The unit cell is labeled as a matrix which means that any tensor in the unit cell, regardless if PEPS tensor or environment tensor, is obtained by shifting the row and column index <code>[r, c]</code> by one, respectively:</p><pre><code class="nohighlight hljs">   |            |          |
---C[r-1,c-1]---T[r-1,c]---T[r-1,c+1]---
   |            ||         ||
---T[r,c-1]=====AA[r,c]====AA[r,c+1]====
   |            ||         ||
---T[r+1,c-1]===AA[r+1,c]==AA[r+1,c+1]==
   |            ||         ||</code></pre><p>The unit cell has periodic boundary conditions, so <code>[r, c]</code> is indexed modulo the size of the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/states/infinitepeps.jl#L63-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPS-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:(TensorKit.AbstractTensorMap{S, 1, 4} where S&lt;:TensorKit.ElementarySpace)" href="#PEPSKit.InfinitePEPS-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:(TensorKit.AbstractTensorMap{S, 1, 4} where S&lt;:TensorKit.ElementarySpace)"><code>PEPSKit.InfinitePEPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePEPS(A::AbstractMatrix{T})</code></pre><p>Create an <code>InfinitePEPS</code> by specifying a matrix containing the PEPS tensors at each site in the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/states/infinitepeps.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPS-Union{Tuple{A}, Tuple{A, A, A}} where A&lt;:(AbstractMatrix{&lt;:Union{Int64, TensorKit.ElementarySpace}})" href="#PEPSKit.InfinitePEPS-Union{Tuple{A}, Tuple{A, A, A}} where A&lt;:(AbstractMatrix{&lt;:Union{Int64, TensorKit.ElementarySpace}})"><code>PEPSKit.InfinitePEPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePEPS(
    f=randn, T=ComplexF64, Pspaces::A, Nspaces::A, [Espaces::A]
) where {A&lt;:AbstractMatrix{&lt;:Union{Int,ElementarySpace}}}</code></pre><p>Create an <code>InfinitePEPS</code> by specifying the physical, north virtual and east virtual spaces of the PEPS tensor at each site in the unit cell as a matrix. Each individual space can be specified as either an <code>Int</code> or an <code>ElementarySpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/states/infinitepeps.jl#L33-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfinitePEPS-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S&lt;:Union{Int64, TensorKit.ElementarySpace}" href="#PEPSKit.InfinitePEPS-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S&lt;:Union{Int64, TensorKit.ElementarySpace}"><code>PEPSKit.InfinitePEPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfinitePEPS(f=randn, T=ComplexF64, Pspace, Nspace, [Espace]; unitcell=(1,1))</code></pre><p>Create an InfinitePEPS by specifying its physical, north and east spaces and unit cell. Spaces can be specified either via <code>Int</code> or via <code>ElementarySpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/states/infinitepeps.jl#L87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfiniteTransferPEPO" href="#PEPSKit.InfiniteTransferPEPO"><code>PEPSKit.InfiniteTransferPEPO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InfiniteTransferPEPO{T,O}</code></pre><p>Represents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the expectation value of an <code>InfinitePEPO</code> between &#39;ket&#39; and &#39;bra&#39; <code>InfinitePEPS</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/transferpepo.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfiniteTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any, Any}" href="#PEPSKit.InfiniteTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any, Any}"><code>PEPSKit.InfiniteTransferPEPO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfiniteTransferPEPO(T::InfinitePEPS, O::InfinitePEPO, dir, row)</code></pre><p>Constructs a transfer operator corresponding to a single row of a partition function representing the expectation value of <code>O</code> for the state <code>T</code>. The partition function is first rotated such that the direction <code>dir</code> faces north, after which its <code>row</code>th row from the north is selected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/transferpepo.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfiniteTransferPEPS" href="#PEPSKit.InfiniteTransferPEPS"><code>PEPSKit.InfiniteTransferPEPS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InfiniteTransferPEPS{T}</code></pre><p>Represents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the overlap between &#39;ket&#39; and &#39;bra&#39; <code>InfinitePEPS</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/transferpeps.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.InfiniteTransferPEPS-Tuple{InfinitePEPS, Any, Any}" href="#PEPSKit.InfiniteTransferPEPS-Tuple{InfinitePEPS, Any, Any}"><code>PEPSKit.InfiniteTransferPEPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InfiniteTransferPEPS(T::InfinitePEPS, dir, row)</code></pre><p>Constructs a transfer operator corresponding to a single row of a partition function representing the norm of the state <code>T</code>. The partition function is first rotated such that the direction <code>dir</code> faces north, after which its <code>row</code>th row from the north is selected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/transferpeps.jl#L14-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.IterSVD" href="#PEPSKit.IterSVD"><code>PEPSKit.IterSVD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IterSVD(; alg = KrylovKit.GKL(), fallback_threshold = Inf)</code></pre><p>Iterative SVD solver based on KrylovKit&#39;s GKL algorithm, adapted to (symmmetric) tensors. The number of targeted singular values is set via the <code>TruncationSpace</code> in <code>ProjectorAlg</code>. In particular, this make it possible to specify the targeted singular values block-wise. In case the symmetry block is too small as compared to the number of singular values, or the iterative SVD didn&#39;t converge, the algorithm falls back to a dense SVD.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/utility/svd.jl#L42-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.ManualIter" href="#PEPSKit.ManualIter"><code>PEPSKit.ManualIter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ManualIter &lt;: GradMode</code></pre><p>Gradient mode for CTMRG using manual iteration to solve the linear problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/algorithms/peps_opt.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.NaiveAD" href="#PEPSKit.NaiveAD"><code>PEPSKit.NaiveAD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NaiveAD &lt;: GradMode</code></pre><p>Gradient mode for CTMRG using AD.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/algorithms/peps_opt.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.NonTruncSVDAdjoint" href="#PEPSKit.NonTruncSVDAdjoint"><code>PEPSKit.NonTruncSVDAdjoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NonTruncAdjoint(; lorentz_broadening = 0.0)</code></pre><p>Old SVD adjoint that does not account for the truncated part of truncated SVDs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/utility/svd.jl#L171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.PEPOTensor" href="#PEPSKit.PEPOTensor"><code>PEPSKit.PEPOTensor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const PEPOTensor{S}</code></pre><p>Default type for PEPO tensors with a single incoming and outgoing physical index, and 4 virtual indices, conventionally ordered as: O : P ⊗ P&#39; ← N ⊗ E ⊗ S ⊗ W.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/states/abstractpeps.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.PEPSOptimize" href="#PEPSKit.PEPSOptimize"><code>PEPSKit.PEPSOptimize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PEPSOptimize{G}(; boundary_alg = CTMRG(), optimizer::OptimKit.OptimizationAlgorithm = LBFGS()
                reuse_env::Bool = true, gradient_alg::G, verbosity::Int = 0)</code></pre><p>Algorithm struct that represent PEPS ground-state optimization using AD. Set the algorithm to contract the infinite PEPS in <code>boundary_alg</code>; currently only <code>CTMRG</code> is supported. The <code>optimizer</code> computes the gradient directions based on the CTMRG gradient and updates the PEPS parameters. In this optimization, the CTMRG runs can be started on the converged environments of the previous optimizer step by setting <code>reuse_env</code> to true. Otherwise a random environment is used at each step. The CTMRG gradient itself is computed using the <code>gradient_alg</code> algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/algorithms/peps_opt.jl#L32-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.PEPSTensor" href="#PEPSKit.PEPSTensor"><code>PEPSKit.PEPSTensor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const PEPSTensor{S}</code></pre><p>Default type for PEPS tensors with a single physical index, and 4 virtual indices, conventionally ordered as: <span>$T : P ← N ⊗ E ⊗ S ⊗ W$</span>. Here, <span>$P$</span>, <span>$N$</span>, <span>$E$</span>, <span>$S$</span> and <span>$W$</span> denote the physics, north, east, south and west spaces, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/states/abstractpeps.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.PEPSTensor-Union{Tuple{S}, Tuple{T}, Tuple{Any, Type{T}, S, S}, Tuple{Any, Type{T}, S, S, S}, Tuple{Any, Type{T}, Vararg{S, 4}}, Tuple{Any, Type{T}, Vararg{S, 5}}} where {T, S&lt;:TensorKit.ElementarySpace}" href="#PEPSKit.PEPSTensor-Union{Tuple{S}, Tuple{T}, Tuple{Any, Type{T}, S, S}, Tuple{Any, Type{T}, S, S, S}, Tuple{Any, Type{T}, Vararg{S, 4}}, Tuple{Any, Type{T}, Vararg{S, 5}}} where {T, S&lt;:TensorKit.ElementarySpace}"><code>PEPSKit.PEPSTensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PEPSTensor(f, ::Type{T}, Pspace::S, Nspace::S,
           [Espace::S], [Sspace::S], [Wspace::S]) where {T,S&lt;:ElementarySpace}
PEPSTensor(f, ::Type{T}, Pspace::Int, Nspace::Int,
           [Espace::Int], [Sspace::Int], [Wspace::Int]) where {T}</code></pre><p>Construct a PEPS tensor based on the physical, north, east, west and south spaces. Alternatively, only the space dimensions can be provided and ℂ is assumed as the field. The tensor elements are generated based on <code>f</code> and the element type is specified in <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/states/abstractpeps.jl#L10-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.ProjectorAlg" href="#PEPSKit.ProjectorAlg"><code>PEPSKit.ProjectorAlg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ProjectorAlg{S}(; svd_alg = TensorKit.SVD(), trscheme = TensorKit.notrunc(),
                       fixedspace = false, verbosity = 0)</code></pre><p>Algorithm struct collecting all projector related parameters. The truncation scheme has to be a <code>TensorKit.TruncationScheme</code>, and some SVD algorithms might have further restrictions on what kind of truncation scheme can be used. If <code>fixedspace</code> is true, the truncation scheme is set to <code>truncspace(V)</code> where <code>V</code> is the environment bond space, adjusted to the corresponding environment direction/unit cell entry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/algorithms/ctmrg.jl#L11-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.SVDAdjoint" href="#PEPSKit.SVDAdjoint"><code>PEPSKit.SVDAdjoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SVDAdjoint(; fwd_alg = TensorKit.SVD(), rrule_alg = nothing,
                  broadening = nothing)</code></pre><p>Wrapper for a SVD algorithm <code>fwd_alg</code> with a defined reverse rule <code>rrule_alg</code>. If <code>isnothing(rrule_alg)</code>, Zygote differentiates the forward call automatically. In case of degenerate singular values, one might need a <code>broadening</code> scheme which removes the divergences from the adjoint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/utility/svd.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.TransferPEPOMultiline" href="#PEPSKit.TransferPEPOMultiline"><code>PEPSKit.TransferPEPOMultiline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const TransferPEPOMultiline = MPSKit.Multiline{&lt;:InfiniteTransferPEPO}</code></pre><p>Type that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap of an <code>InfinitePEPO</code> between &#39;ket&#39; and &#39;bra&#39; <code>InfinitePEPS</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/transferpepo.jl#L69-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.TransferPEPOMultiline-Tuple{InfinitePEPS, InfinitePEPO, Any}" href="#PEPSKit.TransferPEPOMultiline-Tuple{InfinitePEPS, InfinitePEPO, Any}"><code>PEPSKit.TransferPEPOMultiline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TransferPEPOMultiline(T::InfinitePEPS, O::InfinitePEPO, dir)</code></pre><p>Construct a multi-row transfer operator corresponding to the partition function representing the expectation value of <code>O</code> for the state <code>T</code>. The partition function is first rotated such that the direction <code>dir</code> faces north.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/transferpepo.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.TransferPEPSMultiline" href="#PEPSKit.TransferPEPSMultiline"><code>PEPSKit.TransferPEPSMultiline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const TransferPEPSMultiline = MPSKit.Multiline{&lt;:InfiniteTransferPEPS}</code></pre><p>Type that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap between &#39;ket&#39; and &#39;bra&#39; <code>InfinitePEPS</code> states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/transferpeps.jl#L35-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.TransferPEPSMultiline-Tuple{InfinitePEPS, Any}" href="#PEPSKit.TransferPEPSMultiline-Tuple{InfinitePEPS, Any}"><code>PEPSKit.TransferPEPSMultiline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TransferPEPSMultiline(T::InfinitePEPS, dir)</code></pre><p>Construct a multi-row transfer operator corresponding to the partition function representing the norm of the state <code>T</code>. The partition function is first rotated such that the direction <code>dir</code> faces north.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/transferpeps.jl#L47-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSKit.expectation_value-Tuple{Any, Any}" href="#MPSKit.expectation_value-Tuple{Any, Any}"><code>MPSKit.expectation_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MPSKit.expectation_value(st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO})
MPSKit.expectation_value(st::MPSMultiline, op::Union{TransferPEPSMultiline,TransferPEPOMultiline})</code></pre><p>Compute expectation value of the transfer operator <code>op</code> for the state <code>st</code> for each site in the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/transferpeps.jl#L133-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSKit.leading_boundary-Tuple{Any, Any, Any}" href="#MPSKit.leading_boundary-Tuple{Any, Any, Any}"><code>MPSKit.leading_boundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MPSKit.leading_boundary(
    st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO}, alg, [envs]
)
MPSKit.leading_boundary(
    st::MPSMulitline, op::Union{TransferPEPSMultiline,TransferPEPOMultiline}, alg, [envs]
)</code></pre><p>Approximate the leading boundary MPS eigenvector for the transfer operator <code>op</code> using <code>st</code> as initial guess.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/transferpeps.jl#L168-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSKit.leading_boundary-Tuple{Any, CTMRG}" href="#MPSKit.leading_boundary-Tuple{Any, CTMRG}"><code>MPSKit.leading_boundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MPSKit.leading_boundary([envinit], state, alg::CTMRG)</code></pre><p>Contract <code>state</code> using CTMRG and return the CTM environment. Per default, a random initial environment is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/algorithms/ctmrg.jl#L62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit._rrule-Tuple{Nothing, ChainRulesCore.RuleConfig, Any, Vararg{Any}}" href="#PEPSKit._rrule-Tuple{Nothing, ChainRulesCore.RuleConfig, Any, Vararg{Any}}"><code>PEPSKit._rrule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_rrule(alg_rrule, config, f, args...; kwargs...) -&gt; ∂f, ∂args...</code></pre><p>Customize the pullback of a function <code>f</code>. This function can specialize on its first argument in order to have multiple implementations for a pullback. If no specialization is needed, the default <code>alg_rrule=nothing</code> results in the default AD pullback.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>No tangent is expected for the <code>alg_rrule</code> argument</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/utility/hook_pullback.jl#L37-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.calc_elementwise_convergence-Tuple{CTMRGEnv, CTMRGEnv}" href="#PEPSKit.calc_elementwise_convergence-Tuple{CTMRGEnv, CTMRGEnv}"><code>PEPSKit.calc_elementwise_convergence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_elementwise_convergence(envfinal, envfix; atol=1e-6)</code></pre><p>Check if the element-wise difference of the corner and edge tensors of the final and fixed CTMRG environments are below some tolerance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/algorithms/ctmrg.jl#L287-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.checklattice-Tuple" href="#PEPSKit.checklattice-Tuple"><code>PEPSKit.checklattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">checklattice(Bool, args...)
checklattice(args...)</code></pre><p>Helper function for checking lattice compatibility. The first version returns a boolean, while the second version throws an error if the lattices do not match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/localoperator.jl#L471-L477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.contract_localnorm-Union{Tuple{N}, Tuple{Tuple{Vararg{CartesianIndex{2}, N}}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where N" href="#PEPSKit.contract_localnorm-Union{Tuple{N}, Tuple{Tuple{Vararg{CartesianIndex{2}, N}}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where N"><code>PEPSKit.contract_localnorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contract_localnorm(inds, peps, env)</code></pre><p>Contract a local norm of the PEPS <code>peps</code> around indices <code>inds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/localoperator.jl#L245-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.contract_localoperator-Union{Tuple{N}, Tuple{S}, Tuple{Tuple{Vararg{CartesianIndex{2}, N}}, TensorKit.AbstractTensorMap{S, N, N}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where {S, N}" href="#PEPSKit.contract_localoperator-Union{Tuple{N}, Tuple{S}, Tuple{Tuple{Vararg{CartesianIndex{2}, N}}, TensorKit.AbstractTensorMap{S, N, N}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where {S, N}"><code>PEPSKit.contract_localoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contract_localoperator(inds, O, peps, env)</code></pre><p>Contract a local operator <code>O</code> on the PEPS <code>peps</code> at the indices <code>inds</code> using the environment <code>env</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/localoperator.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.ctmrg_iter-Union{Tuple{T}, Tuple{C}, Tuple{Any, CTMRGEnv{C, T}, CTMRG}} where {C, T}" href="#PEPSKit.ctmrg_iter-Union{Tuple{T}, Tuple{C}, Tuple{Any, CTMRGEnv{C, T}, CTMRG}} where {C, T}"><code>PEPSKit.ctmrg_iter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ctmrg_iter(state, env::CTMRGEnv{C,T}, alg::CTMRG) where {C,T}</code></pre><p>Perform one iteration of CTMRG that maps the <code>state</code> and <code>env</code> to a new environment, and also return the truncation error. One CTMRG iteration consists of four <code>left_move</code> calls and 90 degree rotations, such that the environment is grown and renormalized in all four directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/algorithms/ctmrg.jl#L321-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fixedpoint-Union{Tuple{T}, Tuple{InfinitePEPS{T}, Any, PEPSOptimize}, Tuple{InfinitePEPS{T}, Any, PEPSOptimize, CTMRGEnv}} where T" href="#PEPSKit.fixedpoint-Union{Tuple{T}, Tuple{InfinitePEPS{T}, Any, PEPSOptimize}, Tuple{InfinitePEPS{T}, Any, PEPSOptimize, CTMRGEnv}} where T"><code>PEPSKit.fixedpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fixedpoint(ψ₀::InfinitePEPS{T}, H, alg::PEPSOptimize, [env₀::CTMRGEnv]) where {T}</code></pre><p>Optimize <code>ψ₀</code> with respect to the Hamiltonian <code>H</code> according to the parameters supplied in <code>alg</code>. The initial environment <code>env₀</code> serves as an initial guess for the first CTMRG run. By default, a random initial environment is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/algorithms/peps_opt.jl#L53-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.fpgrad" href="#PEPSKit.fpgrad"><code>PEPSKit.fpgrad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fpgrad(∂F∂x, ∂f∂x, ∂f∂A, y0, alg)</code></pre><p>Compute the gradient of the cost function for CTMRG by solving the following equation:</p><p>dx = ∑ₙ (∂f∂x)ⁿ ∂f∂A dA = (1 - ∂f∂x)⁻¹ ∂f∂A dA</p><p>where <code>∂F∂x</code> is the gradient of the cost function with respect to the PEPS tensors, <code>∂f∂x</code> is the partial gradient of the CTMRG iteration with respect to the environment tensors, <code>∂f∂A</code> is the partial gradient of the CTMRG iteration with respect to the PEPS tensors, and <code>y0</code> is the initial guess for the fixed-point iteration. The function returns the gradient <code>dx</code> of the fixed-point iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/algorithms/peps_opt.jl#L135-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.gauge_fix-Union{Tuple{T}, Tuple{C}, Tuple{CTMRGEnv{C, T}, CTMRGEnv{C, T}}} where {C, T}" href="#PEPSKit.gauge_fix-Union{Tuple{T}, Tuple{C}, Tuple{CTMRGEnv{C, T}, CTMRGEnv{C, T}}} where {C, T}"><code>PEPSKit.gauge_fix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gauge_fix(envprev::CTMRGEnv{C,T}, envfinal::CTMRGEnv{C,T}) where {C,T}</code></pre><p>Fix the gauge of <code>envfinal</code> based on the previous environment <code>envprev</code>. This assumes that the <code>envfinal</code> is the result of one CTMRG iteration on <code>envprev</code>. Given that the CTMRG run is converged, the returned environment will be element-wise converged to <code>envprev</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/algorithms/ctmrg.jl#L119-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.hook_pullback-Tuple{Any, Vararg{Any}}" href="#PEPSKit.hook_pullback-Tuple{Any, Vararg{Any}}"><code>PEPSKit.hook_pullback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hook_pullback(f, args...; alg_rrule=nothing, kwargs...)</code></pre><p>Wrapper function to customize the pullback of a function <code>f</code>. This function is equivalent to <code>f(args...; kwargs...)</code>, but the pullback can be customized by implementing the following function:</p><pre><code class="nohighlight hljs">_rrule(alg_rrule, config, f, args...; kwargs...) -&gt; NoTangent(), ∂f, ∂args...</code></pre><p>This function can specialize on its first argument in order to customize the pullback. If no specialization is needed, the default <code>alg_rrule=nothing</code> results in the default AD pullback.</p><p>See also <a href="#PEPSKit._rrule-Tuple{Nothing, ChainRulesCore.RuleConfig, Any, Vararg{Any}}"><code>_rrule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/utility/hook_pullback.jl#L10-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.initializeMPS-Union{Tuple{S}, Tuple{InfiniteTransferPEPS, AbstractVector{S}}} where S" href="#PEPSKit.initializeMPS-Union{Tuple{S}, Tuple{InfiniteTransferPEPS, AbstractVector{S}}} where S"><code>PEPSKit.initializeMPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initializeMPS(
    O::Union{InfiniteTransferPEPS,InfiniteTransferPEPO},
    virtualspaces::AbstractArray{&lt;:ElementarySpace,1}
)
initializeMPS(
    O::Union{TransferPEPSMultiline,TransferPEPOMultiline},
    virtualspaces::AbstractArray{&lt;:ElementarySpace,2}
)</code></pre><p>Inialize a boundary MPS for the transfer operator <code>O</code> by specifying an array of virtual spaces consistent with the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/transferpeps.jl#L58-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.left_move-Union{Tuple{T}, Tuple{C}, Tuple{Any, CTMRGEnv{C, T}, ProjectorAlg}} where {C, T}" href="#PEPSKit.left_move-Union{Tuple{T}, Tuple{C}, Tuple{Any, CTMRGEnv{C, T}, ProjectorAlg}} where {C, T}"><code>PEPSKit.left_move</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">left_move(state, env::CTMRGEnv{C,T}, alg::CTMRG) where {C,T}</code></pre><p>Grow, project and renormalize the environment <code>env</code> in west direction. Return the updated environment as well as the projectors and truncation error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/algorithms/ctmrg.jl#L342-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.projector_type-Tuple{DataType, Any}" href="#PEPSKit.projector_type-Tuple{DataType, Any}"><code>PEPSKit.projector_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projector_type(T::DataType, size)</code></pre><p>Create two arrays of specified <code>size</code> that contain undefined tensors representing left and right acting projectors, respectively. The projector types are inferred from the TensorMap type <code>T</code> which avoids having to recompute transpose tensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/utility/util.jl#L52-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.rotate_north-Tuple{Any, Any}" href="#PEPSKit.rotate_north-Tuple{Any, Any}"><code>PEPSKit.rotate_north</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate_north(t, dir)</code></pre><p>Rotate north direction of <code>t</code> to <code>dir</code> by successive applications of <code>rotl90</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/utility/rotations.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.square_lattice_heisenberg-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Number" href="#PEPSKit.square_lattice_heisenberg-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Number"><code>PEPSKit.square_lattice_heisenberg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">square_lattice_heisenberg(::Type{T}=ComplexF64; Jx=-1, Jy=1, Jz=-1, unitcell=(1, 1))</code></pre><p>Square lattice Heisenberg model. By default, this implements a single site unit cell via a sublattice rotation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/models.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.square_lattice_pwave-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Number" href="#PEPSKit.square_lattice_pwave-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Number"><code>PEPSKit.square_lattice_pwave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">square_lattice_pwave(::Type{T}=ComplexF64; t=1, μ=2, Δ=1, unitcell=(1, 1))</code></pre><p>Square lattice p-wave superconductor model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/models.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.square_lattice_tf_ising-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Number" href="#PEPSKit.square_lattice_tf_ising-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T&lt;:Number"><code>PEPSKit.square_lattice_tf_ising</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">square_lattice_tf_ising(::Type{T}=ComplexF64; J=1, h=1, unitcell=(1, 1))</code></pre><p>Square lattice transverse field Ising model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/operators/models.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorKit.tsvd-Tuple{TensorKit.AbstractTensorMap, Any}" href="#TensorKit.tsvd-Tuple{TensorKit.AbstractTensorMap, Any}"><code>TensorKit.tsvd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PEPSKit.tsvd(t::AbstractTensorMap, alg; trunc=notrunc(), p=2)</code></pre><p>Wrapper around <code>TensorKit.tsvd</code> which dispatches on the <code>alg</code> argument. This is needed since a custom adjoint for <code>PEPSKit.tsvd</code> may be defined, depending on the algorithm. E.g., for <code>IterSVD</code> the adjoint for a truncated SVD from <code>KrylovKit.svdsolve</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/utility/svd.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.@autoopt-Tuple{Any}" href="#PEPSKit.@autoopt-Tuple{Any}"><code>PEPSKit.@autoopt</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">autoopt(ex)</code></pre><p>Preprocessor macro for <code>@tensor</code> which automatically inserts costs for all symbols that start with a pattern. In particular, all labels that start with <code>d</code>, <code>D</code>, or <code>χ</code> are automatically inserted with the corresponding costs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/utility/autoopt.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.@diffset-Tuple{Any}" href="#PEPSKit.@diffset-Tuple{Any}"><code>PEPSKit.@diffset</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@diffset assign</code></pre><p>Helper macro which allows in-place operations in the forward-pass of Zygote, but resorts to non-mutating operations in the backwards-pass. The expression <code>assign</code> should assign an object to an pre-existing <code>AbstractArray</code> and the use of updating operators is also possible. This is especially needed when in-place assigning tensors to unit-cell arrays of environments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/utility/util.jl#L137-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.@showtypeofgrad-Tuple{Any}" href="#PEPSKit.@showtypeofgrad-Tuple{Any}"><code>PEPSKit.@showtypeofgrad</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@showtypeofgrad(x)</code></pre><p>Macro utility to show to type of the gradient that is about to accumulate for <code>x</code>.</p><p>See also <a href="lib/@ref"><code>Zygote.@showgrad</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/utility/util.jl#L185-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PEPSKit.Defaults" href="#PEPSKit.Defaults"><code>PEPSKit.Defaults</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">module Defaults
    const ctmrg_maxiter = 100
    const ctmrg_miniter = 4
    const ctmrg_tol = 1e-12
    const fpgrad_maxiter = 100
    const fpgrad_tol = 1e-6
end</code></pre><p>Module containing default values that represent typical algorithm parameters.</p><ul><li><code>ctmrg_maxiter = 100</code>: Maximal number of CTMRG iterations per run</li><li><code>ctmrg_miniter = 4</code>: Minimal number of CTMRG carried out</li><li><code>ctmrg_tol = 1e-12</code>: Tolerance checking singular value and norm convergence</li><li><code>fpgrad_maxiter = 100</code>: Maximal number of iterations for computing the CTMRG fixed-point gradient</li><li><code>fpgrad_tol = 1e-6</code>: Convergence tolerance for the fixed-point gradient iteration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/PEPSKit.jl/blob/9a6b40960619edae88f754515fc9d89413b44f44/src/PEPSKit.jl#L39-L55">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 16 July 2024 07:45">Tuesday 16 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
