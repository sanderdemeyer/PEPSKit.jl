var documenterSearchIndex = {"docs":
[{"location":"lib/lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/lib/","page":"Library","title":"Library","text":"Modules = [PEPSKit, PEPSKit.Defaults]\nFilter = t -> !(t in [PEPSKit.PEPS_∂∂AC, PEPSKit.PEPS_∂∂C, PEPSKit.PEPO_∂∂AC, PEPSKit.PEPO_∂∂C])","category":"page"},{"location":"lib/lib/#PEPSKit.AbstractPEPO","page":"Library","title":"PEPSKit.AbstractPEPO","text":"abstract type AbstractPEPO end\n\nAbstract supertype for a 2D projected entangled-pair operator.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.AbstractPEPS","page":"Library","title":"PEPSKit.AbstractPEPS","text":"abstract type AbstractPEPS end\n\nAbstract supertype for a 2D projected entangled-pair state.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRG","page":"Library","title":"PEPSKit.CTMRG","text":"CTMRG(; tol=Defaults.ctmrg_tol, maxiter=Defaults.ctmrg_maxiter,\n      miniter=Defaults.ctmrg_miniter, verbosity=0,\n      svd_alg=TensorKit.SVD(), trscheme=FixedSpaceTruncation())\n\nAlgorithm struct that represents the CTMRG algorithm for contracting infinite PEPS. Each CTMRG run is converged up to tol where the singular value convergence of the corners as well as the norm is checked. The maximal and minimal number of CTMRG iterations is set with maxiter and miniter. Different levels of output information are printed depending on verbosity, where 0 suppresses all output, 1 only prints warnings, 2 gives information at the start and end, and 3 prints information every iteration. The projectors are computed from svd_alg SVDs where the truncation scheme is set via  trscheme.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGEnv","page":"Library","title":"PEPSKit.CTMRGEnv","text":"struct CTMRGEnv{C,T}\n\nCorner transfer-matrix environment containing unit-cell arrays of corner and edge tensors. The last two indices of the arrays correspond to the row and column indices of the unit cell, whereas the first index corresponds to the direction of the corner or edge tensor. The directions are labeled in clockwise direction, starting from the north-west corner and north edge respectively.\n\nGiven arrays of corners c and edges t, they connect to the PEPS tensors at site (r, c) in the unit cell as:\n\n   c[1,r-1,c-1]---t[1,r-1,c]----c[2,r-1,c+1]\n   |              ||            |\n   t[4,r,c-1]=====AA[r,c]=======t[2,r,c+1]\n   |              ||            |\n   c[4,r+1,c-1]---t[3,r+1,c]----c[3,r+1,c+1]\n\nFields\n\ncorners::Array{C,3}: Array of corner tensors.\nedges::Array{T,3}: Array of edge tensors.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{A}, Tuple{A, A, A}, NTuple{4, A}, NTuple{5, A}, NTuple{6, A}} where A<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, ComplexF64], Ds_north, Ds_east::A, chis_north::A, [chis_east::A], [chis_south::A], [chis_west::A]\n) where {A<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\n\nConstruct a CTMRG environment by specifying matrices of north and east virtual spaces of the corresponding InfinitePEPS and the north, east, south and west virtual spaces of the environment. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual environment spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site (r, c), chis_north[r, c] corresponds to the east space of the north edge tensor, chis_east[r, c] corresponds to the north space of the east edge tensor, chis_south[r, c] corresponds to the east space of the south edge tensor, and chis_west[r, c] corresponds to the north space of the west edge tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{A}, Tuple{InfinitePEPS, A}, Tuple{InfinitePEPS, A, A}, Tuple{InfinitePEPS, A, A, A}, Tuple{InfinitePEPS, Vararg{A, 4}}} where A<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, T=ComplexF64], peps::InfinitePEPS, chis_north::A, [chis_east::A], [chis_south::A], [chis_west::A]\n) where {A<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\n\nConstruct a CTMRG environment by specifying a corresponding InfinitePEPS, and the north, east, south and west virtual spaces of the environment as matrices. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site (r, c), chis_north[r, c] corresponds to the east space of the north edge tensor, chis_east[r, c] corresponds to the north space of the east edge tensor, chis_south[r, c] corresponds to the east space of the south edge tensor, and chis_west[r, c] corresponds to the north space of the west edge tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{InfinitePEPS, S}, Tuple{InfinitePEPS, S, S}, Tuple{InfinitePEPS, S, S, S}, Tuple{InfinitePEPS, Vararg{S, 4}}} where S<:Union{Int64, TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    peps::InfinitePEPS, chi_north::S, [chi_east::S], [chi_south::S], [chi_west::S],\n) where {S<:Union{Int,ElementarySpace}}\n\nConstruct a CTMRG environment by specifying a corresponding InfinitePEPS, and the north, east, south and west virtual spaces of the environment. By default, the virtual spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to virtual space of the corresponding edge tensor for each direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{S, S, S}, NTuple{4, S}, NTuple{5, S}, NTuple{6, S}} where S<:Union{Int64, TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, ComplexF64], D_north::S, D_south::S, chi_north::S, [chi_east::S], [chi_south::S], [chi_west::S]; unitcell::Tuple{Int,Int}=(1, 1),\n) where {S<:Union{Int,ElementarySpace}}\n\nConstruct a CTMRG environment by specifying the north and east virtual spaces of the corresponding InfinitePEPS and the north, east, south and west virtual spaces of the environment. The PEPS unit cell can be specified by the unitcell keyword argument. By default, the virtual environment spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to virtual space of the corresponding edge tensor for each direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.FixedSpaceTruncation","page":"Library","title":"PEPSKit.FixedSpaceTruncation","text":"FixedSpaceTruncation <: TensorKit.TruncationScheme\n\nCTMRG specific truncation scheme for tsvd which keeps the bond space on which the SVD is performed fixed. Since different environment directions and unit cell entries might have different spaces, this truncation style is different from TruncationSpace.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.GeomSum","page":"Library","title":"PEPSKit.GeomSum","text":"struct GeomSum <: GradMode\n\nGradient mode for CTMRG using explicit evaluation of the geometric sum.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPO","page":"Library","title":"PEPSKit.InfinitePEPO","text":"struct InfinitePEPO{T<:PEPOTensor}\n\nRepresents an infinite projected entangled-pair operator (PEPO) on a 3D cubic lattice.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Tuple{T} where T<:(TensorKit.AbstractTensorMap{S, 2, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(A; unitcell=(1, 1, 1))\n\nCreate an InfinitePEPO by specifying a tensor and unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T<:(TensorKit.AbstractTensorMap{S, 2, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(A::AbstractArray{T, 3})\n\nAllow users to pass in an array of tensors.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{A}, Tuple{A, A}, Tuple{A, A, A}} where A<:(AbstractArray{<:TensorKit.ElementarySpace, 3})","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(f=randn, T=ComplexF64, Pspaces, Nspaces, Espaces)\n\nAllow users to pass in arrays of spaces.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(f=randn, T=ComplexF64, Pspace, Nspace, [Espace]; unitcell=(1,1,1))\n\nCreate an InfinitePEPO by specifying its spaces and unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS","page":"Library","title":"PEPSKit.InfinitePEPS","text":"struct InfinitePEPS{T<:PEPSTensor}\n\nRepresents an infinite projected entangled-pair state on a 2D square lattice.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Tuple{T} where T<:(TensorKit.AbstractTensorMap{S, 1, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(A; unitcell=(1, 1))\n\nCreate an InfinitePEPS by specifying a tensor and unit cell.\n\nThe unit cell is labeled as a matrix which means that any tensor in the unit cell, regardless if PEPS tensor or environment tensor, is obtained by shifting the row and column index [r, c] by one, respectively:\n\n   |            |          |\n---C[r-1,c-1]---T[r-1,c]---T[r-1,c+1]---\n   |            ||         ||\n---T[r,c-1]=====AA[r,c]====AA[r,c+1]====\n   |            ||         ||\n---T[r+1,c-1]===AA[r+1,c]==AA[r+1,c+1]==\n   |            ||         ||\n\nThe unit cell has periodic boundary conditions, so [r, c] is indexed modulo the size of the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:(TensorKit.AbstractTensorMap{S, 1, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(A::AbstractMatrix{T})\n\nCreate an InfinitePEPS by specifying a matrix containing the PEPS tensors at each site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Union{Tuple{A}, Tuple{A, A, A}} where A<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(\n    f=randn, T=ComplexF64, Pspaces::A, Nspaces::A, [Espaces::A]\n) where {A<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\n\nCreate an InfinitePEPS by specifying the physical, north virtual and east virtual spaces of the PEPS tensor at each site in the unit cell as a matrix. Each individual space can be specified as either an Int or an ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S<:Union{Int64, TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(f=randn, T=ComplexF64, Pspace, Nspace, [Espace]; unitcell=(1,1))\n\nCreate an InfinitePEPS by specifying its physical, north and east spaces and unit cell. Spaces can be specified either via Int or via ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPO","page":"Library","title":"PEPSKit.InfiniteTransferPEPO","text":"InfiniteTransferPEPO{T,O}\n\nRepresents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the expectation value of an InfinitePEPO between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any, Any}","page":"Library","title":"PEPSKit.InfiniteTransferPEPO","text":"InfiniteTransferPEPO(T::InfinitePEPS, O::InfinitePEPO, dir, row)\n\nConstructs a transfer operator corresponding to a single row of a partition function representing the expectation value of O for the state T. The partition function is first rotated such that the direction dir faces north, after which its rowth row from the north is selected.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPS","page":"Library","title":"PEPSKit.InfiniteTransferPEPS","text":"InfiniteTransferPEPS{T}\n\nRepresents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the overlap between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPS-Tuple{InfinitePEPS, Any, Any}","page":"Library","title":"PEPSKit.InfiniteTransferPEPS","text":"InfiniteTransferPEPS(T::InfinitePEPS, dir, row)\n\nConstructs a transfer operator corresponding to a single row of a partition function representing the norm of the state T. The partition function is first rotated such that the direction dir faces north, after which its rowth row from the north is selected.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.IterSVD","page":"Library","title":"PEPSKit.IterSVD","text":"struct IterSVD(; alg = KrylovKit.GKL(), fallback_threshold = Inf)\n\nIterative SVD solver based on KrylovKit's GKL algorithm, adapted to (symmmetric) tensors. The number of targeted singular values is set via the TruncationSpace in ProjectorAlg. In particular, this make it possible to specify the targeted singular values block-wise. In case the symmetry block is too small as compared to the number of singular values, or the iterative SVD didn't converge, the algorithm falls back to a dense SVD.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ManualIter","page":"Library","title":"PEPSKit.ManualIter","text":"struct ManualIter <: GradMode\n\nGradient mode for CTMRG using manual iteration to solve the linear problem.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.NaiveAD","page":"Library","title":"PEPSKit.NaiveAD","text":"struct NaiveAD <: GradMode\n\nGradient mode for CTMRG using AD.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.NonTruncSVDAdjoint","page":"Library","title":"PEPSKit.NonTruncSVDAdjoint","text":"struct NonTruncAdjoint(; lorentz_broadening = 0.0)\n\nOld SVD adjoint that does not account for the truncated part of truncated SVDs.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPOTensor","page":"Library","title":"PEPSKit.PEPOTensor","text":"const PEPOTensor{S}\n\nDefault type for PEPO tensors with a single incoming and outgoing physical index, and 4 virtual indices, conventionally ordered as: O : P ⊗ P' ← N ⊗ E ⊗ S ⊗ W.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSOptimize","page":"Library","title":"PEPSKit.PEPSOptimize","text":"PEPSOptimize{G}(; boundary_alg = CTMRG(), optimizer::OptimKit.OptimizationAlgorithm = LBFGS()\n                reuse_env::Bool = true, gradient_alg::G, verbosity::Int = 0)\n\nAlgorithm struct that represent PEPS ground-state optimization using AD. Set the algorithm to contract the infinite PEPS in boundary_alg; currently only CTMRG is supported. The optimizer computes the gradient directions based on the CTMRG gradient and updates the PEPS parameters. In this optimization, the CTMRG runs can be started on the converged environments of the previous optimizer step by setting reuse_env to true. Otherwise a random environment is used at each step. The CTMRG gradient itself is computed using the gradient_alg algorithm.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSTensor","page":"Library","title":"PEPSKit.PEPSTensor","text":"const PEPSTensor{S}\n\nDefault type for PEPS tensors with a single physical index, and 4 virtual indices, conventionally ordered as: T  P  N  E  S  W. Here, P, N, E, S and W denote the physics, north, east, south and west spaces, respectively.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSTensor-Union{Tuple{S}, Tuple{T}, Tuple{Any, Type{T}, S, S}, Tuple{Any, Type{T}, S, S, S}, Tuple{Any, Type{T}, Vararg{S, 4}}, Tuple{Any, Type{T}, Vararg{S, 5}}} where {T, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.PEPSTensor","text":"PEPSTensor(f, ::Type{T}, Pspace::S, Nspace::S,\n           [Espace::S], [Sspace::S], [Wspace::S]) where {T,S<:ElementarySpace}\nPEPSTensor(f, ::Type{T}, Pspace::Int, Nspace::Int,\n           [Espace::Int], [Sspace::Int], [Wspace::Int]) where {T}\n\nConstruct a PEPS tensor based on the physical, north, east, west and south spaces. Alternatively, only the space dimensions can be provided and ℂ is assumed as the field. The tensor elements are generated based on f and the element type is specified in T.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ProjectorAlg","page":"Library","title":"PEPSKit.ProjectorAlg","text":"struct ProjectorAlg{S}(; svd_alg = TensorKit.SVD(), trscheme = TensorKit.notrunc(),\n                       fixedspace = false, verbosity = 0)\n\nAlgorithm struct collecting all projector related parameters. The truncation scheme has to be a TensorKit.TruncationScheme, and some SVD algorithms might have further restrictions on what kind of truncation scheme can be used. If fixedspace is true, the truncation scheme is set to truncspace(V) where V is the environment bond space, adjusted to the corresponding environment direction/unit cell entry.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SVDAdjoint","page":"Library","title":"PEPSKit.SVDAdjoint","text":"struct SVDAdjoint(; fwd_alg = TensorKit.SVD(), rrule_alg = nothing,\n                  broadening = nothing)\n\nWrapper for a SVD algorithm fwd_alg with a defined reverse rule rrule_alg. If isnothing(rrule_alg), Zygote differentiates the forward call automatically. In case of degenerate singular values, one might need a broadening scheme which removes the divergences from the adjoint.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.TransferPEPOMultiline","page":"Library","title":"PEPSKit.TransferPEPOMultiline","text":"const TransferPEPOMultiline = MPSKit.Multiline{<:InfiniteTransferPEPO}\n\nType that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap of an InfinitePEPO between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.TransferPEPOMultiline-Tuple{InfinitePEPS, InfinitePEPO, Any}","page":"Library","title":"PEPSKit.TransferPEPOMultiline","text":"TransferPEPOMultiline(T::InfinitePEPS, O::InfinitePEPO, dir)\n\nConstruct a multi-row transfer operator corresponding to the partition function representing the expectation value of O for the state T. The partition function is first rotated such that the direction dir faces north.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.TransferPEPSMultiline","page":"Library","title":"PEPSKit.TransferPEPSMultiline","text":"const TransferPEPSMultiline = MPSKit.Multiline{<:InfiniteTransferPEPS}\n\nType that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.TransferPEPSMultiline-Tuple{InfinitePEPS, Any}","page":"Library","title":"PEPSKit.TransferPEPSMultiline","text":"TransferPEPSMultiline(T::InfinitePEPS, dir)\n\nConstruct a multi-row transfer operator corresponding to the partition function representing the norm of the state T. The partition function is first rotated such that the direction dir faces north.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.expectation_value-Tuple{Any, Any}","page":"Library","title":"MPSKit.expectation_value","text":"MPSKit.expectation_value(st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO})\nMPSKit.expectation_value(st::MPSMultiline, op::Union{TransferPEPSMultiline,TransferPEPOMultiline})\n\nCompute expectation value of the transfer operator op for the state st for each site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.leading_boundary-Tuple{Any, Any, Any}","page":"Library","title":"MPSKit.leading_boundary","text":"MPSKit.leading_boundary(\n    st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO}, alg, [envs]\n)\nMPSKit.leading_boundary(\n    st::MPSMulitline, op::Union{TransferPEPSMultiline,TransferPEPOMultiline}, alg, [envs]\n)\n\nApproximate the leading boundary MPS eigenvector for the transfer operator op using st as initial guess.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.leading_boundary-Tuple{Any, CTMRG}","page":"Library","title":"MPSKit.leading_boundary","text":"MPSKit.leading_boundary([envinit], state, alg::CTMRG)\n\nContract state using CTMRG and return the CTM environment. Per default, a random initial environment is used.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._rrule-Tuple{Nothing, ChainRulesCore.RuleConfig, Any, Vararg{Any}}","page":"Library","title":"PEPSKit._rrule","text":"_rrule(alg_rrule, config, f, args...; kwargs...) -> ∂f, ∂args...\n\nCustomize the pullback of a function f. This function can specialize on its first argument in order to have multiple implementations for a pullback. If no specialization is needed, the default alg_rrule=nothing results in the default AD pullback.\n\nwarning: Warning\nNo tangent is expected for the alg_rrule argument\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.calc_elementwise_convergence-Tuple{CTMRGEnv, CTMRGEnv}","page":"Library","title":"PEPSKit.calc_elementwise_convergence","text":"calc_elementwise_convergence(envfinal, envfix; atol=1e-6)\n\nCheck if the element-wise difference of the corner and edge tensors of the final and fixed CTMRG environments are below some tolerance.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.checklattice-Tuple","page":"Library","title":"PEPSKit.checklattice","text":"checklattice(Bool, args...)\nchecklattice(args...)\n\nHelper function for checking lattice compatibility. The first version returns a boolean, while the second version throws an error if the lattices do not match.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_localnorm-Union{Tuple{N}, Tuple{Tuple{Vararg{CartesianIndex{2}, N}}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where N","page":"Library","title":"PEPSKit.contract_localnorm","text":"contract_localnorm(inds, peps, env)\n\nContract a local norm of the PEPS peps around indices inds.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_localoperator-Union{Tuple{N}, Tuple{S}, Tuple{Tuple{Vararg{CartesianIndex{2}, N}}, TensorKit.AbstractTensorMap{S, N, N}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where {S, N}","page":"Library","title":"PEPSKit.contract_localoperator","text":"contract_localoperator(inds, O, peps, env)\n\nContract a local operator O on the PEPS peps at the indices inds using the environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ctmrg_iter-Union{Tuple{T}, Tuple{C}, Tuple{Any, CTMRGEnv{C, T}, CTMRG}} where {C, T}","page":"Library","title":"PEPSKit.ctmrg_iter","text":"ctmrg_iter(state, env::CTMRGEnv{C,T}, alg::CTMRG) where {C,T}\n\nPerform one iteration of CTMRG that maps the state and env to a new environment, and also return the truncation error. One CTMRG iteration consists of four left_move calls and 90 degree rotations, such that the environment is grown and renormalized in all four directions.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fixedpoint-Union{Tuple{T}, Tuple{InfinitePEPS{T}, Any, PEPSOptimize}, Tuple{InfinitePEPS{T}, Any, PEPSOptimize, CTMRGEnv}} where T","page":"Library","title":"PEPSKit.fixedpoint","text":"fixedpoint(ψ₀::InfinitePEPS{T}, H, alg::PEPSOptimize, [env₀::CTMRGEnv]) where {T}\n\nOptimize ψ₀ with respect to the Hamiltonian H according to the parameters supplied in alg. The initial environment env₀ serves as an initial guess for the first CTMRG run. By default, a random initial environment is used.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fpgrad","page":"Library","title":"PEPSKit.fpgrad","text":"fpgrad(∂F∂x, ∂f∂x, ∂f∂A, y0, alg)\n\nCompute the gradient of the cost function for CTMRG by solving the following equation:\n\ndx = ∑ₙ (∂f∂x)ⁿ ∂f∂A dA = (1 - ∂f∂x)⁻¹ ∂f∂A dA\n\nwhere ∂F∂x is the gradient of the cost function with respect to the PEPS tensors, ∂f∂x is the partial gradient of the CTMRG iteration with respect to the environment tensors, ∂f∂A is the partial gradient of the CTMRG iteration with respect to the PEPS tensors, and y0 is the initial guess for the fixed-point iteration. The function returns the gradient dx of the fixed-point iteration.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.gauge_fix-Union{Tuple{T}, Tuple{C}, Tuple{CTMRGEnv{C, T}, CTMRGEnv{C, T}}} where {C, T}","page":"Library","title":"PEPSKit.gauge_fix","text":"gauge_fix(envprev::CTMRGEnv{C,T}, envfinal::CTMRGEnv{C,T}) where {C,T}\n\nFix the gauge of envfinal based on the previous environment envprev. This assumes that the envfinal is the result of one CTMRG iteration on envprev. Given that the CTMRG run is converged, the returned environment will be element-wise converged to envprev.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.hook_pullback-Tuple{Any, Vararg{Any}}","page":"Library","title":"PEPSKit.hook_pullback","text":"hook_pullback(f, args...; alg_rrule=nothing, kwargs...)\n\nWrapper function to customize the pullback of a function f. This function is equivalent to f(args...; kwargs...), but the pullback can be customized by implementing the following function:\n\n_rrule(alg_rrule, config, f, args...; kwargs...) -> NoTangent(), ∂f, ∂args...\n\nThis function can specialize on its first argument in order to customize the pullback. If no specialization is needed, the default alg_rrule=nothing results in the default AD pullback.\n\nSee also _rrule.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.initializeMPS-Union{Tuple{S}, Tuple{InfiniteTransferPEPS, AbstractVector{S}}} where S","page":"Library","title":"PEPSKit.initializeMPS","text":"initializeMPS(\n    O::Union{InfiniteTransferPEPS,InfiniteTransferPEPO},\n    virtualspaces::AbstractArray{<:ElementarySpace,1}\n)\ninitializeMPS(\n    O::Union{TransferPEPSMultiline,TransferPEPOMultiline},\n    virtualspaces::AbstractArray{<:ElementarySpace,2}\n)\n\nInialize a boundary MPS for the transfer operator O by specifying an array of virtual spaces consistent with the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.left_move-Union{Tuple{T}, Tuple{C}, Tuple{Any, CTMRGEnv{C, T}, ProjectorAlg}} where {C, T}","page":"Library","title":"PEPSKit.left_move","text":"left_move(state, env::CTMRGEnv{C,T}, alg::CTMRG) where {C,T}\n\nGrow, project and renormalize the environment env in west direction. Return the updated environment as well as the projectors and truncation error.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.projector_type-Tuple{DataType, Any}","page":"Library","title":"PEPSKit.projector_type","text":"projector_type(T::DataType, size)\n\nCreate two arrays of specified size that contain undefined tensors representing left and right acting projectors, respectively. The projector types are inferred from the TensorMap type T which avoids having to recompute transpose tensors.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.rotate_north-Tuple{Any, Any}","page":"Library","title":"PEPSKit.rotate_north","text":"rotate_north(t, dir)\n\nRotate north direction of t to dir by successive applications of rotl90.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.square_lattice_heisenberg-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Number","page":"Library","title":"PEPSKit.square_lattice_heisenberg","text":"square_lattice_heisenberg(::Type{T}=ComplexF64; Jx=-1, Jy=1, Jz=-1, unitcell=(1, 1))\n\nSquare lattice Heisenberg model. By default, this implements a single site unit cell via a sublattice rotation.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.square_lattice_pwave-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Number","page":"Library","title":"PEPSKit.square_lattice_pwave","text":"square_lattice_pwave(::Type{T}=ComplexF64; t=1, μ=2, Δ=1, unitcell=(1, 1))\n\nSquare lattice p-wave superconductor model.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.square_lattice_tf_ising-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Number","page":"Library","title":"PEPSKit.square_lattice_tf_ising","text":"square_lattice_tf_ising(::Type{T}=ComplexF64; J=1, h=1, unitcell=(1, 1))\n\nSquare lattice transverse field Ising model.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TensorKit.tsvd-Tuple{TensorKit.AbstractTensorMap, Any}","page":"Library","title":"TensorKit.tsvd","text":"PEPSKit.tsvd(t::AbstractTensorMap, alg; trunc=notrunc(), p=2)\n\nWrapper around TensorKit.tsvd which dispatches on the alg argument. This is needed since a custom adjoint for PEPSKit.tsvd may be defined, depending on the algorithm. E.g., for IterSVD the adjoint for a truncated SVD from KrylovKit.svdsolve is used.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.@autoopt-Tuple{Any}","page":"Library","title":"PEPSKit.@autoopt","text":"autoopt(ex)\n\nPreprocessor macro for @tensor which automatically inserts costs for all symbols that start with a pattern. In particular, all labels that start with d, D, or χ are automatically inserted with the corresponding costs.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.@diffset-Tuple{Any}","page":"Library","title":"PEPSKit.@diffset","text":"@diffset assign\n\nHelper macro which allows in-place operations in the forward-pass of Zygote, but resorts to non-mutating operations in the backwards-pass. The expression assign should assign an object to an pre-existing AbstractArray and the use of updating operators is also possible. This is especially needed when in-place assigning tensors to unit-cell arrays of environments.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.@showtypeofgrad-Tuple{Any}","page":"Library","title":"PEPSKit.@showtypeofgrad","text":"@showtypeofgrad(x)\n\nMacro utility to show to type of the gradient that is about to accumulate for x.\n\nSee also Zygote.@showgrad.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.Defaults","page":"Library","title":"PEPSKit.Defaults","text":"module Defaults\n    const ctmrg_maxiter = 100\n    const ctmrg_miniter = 4\n    const ctmrg_tol = 1e-12\n    const fpgrad_maxiter = 100\n    const fpgrad_tol = 1e-6\nend\n\nModule containing default values that represent typical algorithm parameters.\n\nctmrg_maxiter = 100: Maximal number of CTMRG iterations per run\nctmrg_miniter = 4: Minimal number of CTMRG carried out\nctmrg_tol = 1e-12: Tolerance checking singular value and norm convergence\nfpgrad_maxiter = 100: Maximal number of iterations for computing the CTMRG fixed-point gradient\nfpgrad_tol = 1e-6: Convergence tolerance for the fixed-point gradient iteration\n\n\n\n\n\n","category":"module"},{"location":"man/intro/","page":"Manual","title":"Manual","text":"Coming soon.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For now, refer to the examples folder on GitHub.","category":"page"},{"location":"#PEPSKit.jl","page":"Home","title":"PEPSKit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools for working with projected entangled-pair states","category":"page"},{"location":"","page":"Home","title":"Home","text":"It contracts, it optimizes, it may break.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed through the Julia general registry, via the package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add PEPSKit","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After following the installation process, it should now be possible to load the packages and start simulating. For example, in order to obtain the groundstate of the 2D Heisenberg model, we can use the following code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TensorKit, PEPSKit, KrylovKit, OptimKit\n\n# constructing the Hamiltonian:\nH = square_lattice_heisenberg(; Jx=-1, Jy=1, Jz=-1) # sublattice rotation to obtain single-site unit cell\n\n# configuring the parameters\nD = 2\nchi = 20\nctm_alg = CTMRG(; tol=1e-10, miniter=4, maxiter=100, verbosity=1, trscheme=truncdim(chi))\nopt_alg = PEPSOptimize(;\n    boundary_alg=ctm_alg,\n    optimizer=LBFGS(4; maxiter=100, gradtol=1e-4, verbosity=2),\n    gradient_alg=GMRES(; tol=1e-6, maxiter=100),\n    reuse_env=true,\n    verbosity=2,\n)\n\n# ground state search\nstate = InfinitePEPS(2, D)\nctm = leading_boundary(CTMRGEnv(state, ComplexSpace(chi)), state, ctm_alg)\nresult = fixedpoint(state, H, opt_alg, ctm)\n\n@show result.E # -0.6625...","category":"page"}]
}
