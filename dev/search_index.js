var documenterSearchIndex = {"docs":
[{"location":"lib/lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/lib/","page":"Library","title":"Library","text":"Modules = [PEPSKit, PEPSKit.Defaults]\nFilter = t -> !(t in [PEPSKit.PEPS_∂∂AC, PEPSKit.PEPS_∂∂C, PEPSKit.PEPO_∂∂AC, PEPSKit.PEPO_∂∂C])","category":"page"},{"location":"lib/lib/#PEPSKit.AbstractPEPO","page":"Library","title":"PEPSKit.AbstractPEPO","text":"abstract type AbstractPEPO end\n\nAbstract supertype for a 2D projected entangled-pair operator.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.AbstractPEPS","page":"Library","title":"PEPSKit.AbstractPEPS","text":"abstract type AbstractPEPS end\n\nAbstract supertype for a 2D projected entangled-pair state.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGAlgorithm","page":"Library","title":"PEPSKit.CTMRGAlgorithm","text":"CTMRGAlgorithm\n\nAbstract super type for the corner transfer matrix renormalization group (CTMRG) algorithm for contracting infinite PEPS.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGEnv","page":"Library","title":"PEPSKit.CTMRGEnv","text":"struct CTMRGEnv{C,T}\n\nCorner transfer-matrix environment containing unit-cell arrays of corner and edge tensors. The last two indices of the arrays correspond to the row and column indices of the unit cell, whereas the first index corresponds to the direction of the corner or edge tensor. The directions are labeled in clockwise direction, starting from the north-west corner and north edge respectively.\n\nGiven arrays of corners c and edges t, they connect to the PEPS tensors at site (r, c) in the unit cell as:\n\n   c[1,r-1,c-1]---t[1,r-1,c]----c[2,r-1,c+1]\n   |              ||            |\n   t[4,r,c-1]=====AA[r,c]=======t[2,r,c+1]\n   |              ||            |\n   c[4,r+1,c-1]---t[3,r+1,c]----c[3,r+1,c+1]\n\nFields\n\ncorners::Array{C,3}: Array of corner tensors.\nedges::Array{T,3}: Array of edge tensors.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{A}, Tuple{A, A, A}, NTuple{4, A}, NTuple{5, A}, NTuple{6, A}} where A<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, ComplexF64], Ds_north, Ds_east::A, chis_north::A, [chis_east::A], [chis_south::A], [chis_west::A]\n) where {A<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\n\nConstruct a CTMRG environment by specifying matrices of north and east virtual spaces of the corresponding InfinitePEPS and the north, east, south and west virtual spaces of the environment. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual environment spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site (r, c), chis_north[r, c] corresponds to the east space of the north edge tensor, chis_east[r, c] corresponds to the north space of the east edge tensor, chis_south[r, c] corresponds to the east space of the south edge tensor, and chis_west[r, c] corresponds to the north space of the west edge tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{A}, Tuple{InfinitePEPS, A}, Tuple{InfinitePEPS, A, A}, Tuple{InfinitePEPS, A, A, A}, Tuple{InfinitePEPS, Vararg{A, 4}}} where A<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, T=ComplexF64], peps::InfinitePEPS, chis_north::A, [chis_east::A], [chis_south::A], [chis_west::A]\n) where {A<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\n\nConstruct a CTMRG environment by specifying a corresponding InfinitePEPS, and the north, east, south and west virtual spaces of the environment as matrices. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site (r, c), chis_north[r, c] corresponds to the east space of the north edge tensor, chis_east[r, c] corresponds to the north space of the east edge tensor, chis_south[r, c] corresponds to the east space of the south edge tensor, and chis_west[r, c] corresponds to the north space of the west edge tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{InfinitePEPS, S}, Tuple{InfinitePEPS, S, S}, Tuple{InfinitePEPS, S, S, S}, Tuple{InfinitePEPS, Vararg{S, 4}}} where S<:Union{Int64, TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    peps::InfinitePEPS, chi_north::S, [chi_east::S], [chi_south::S], [chi_west::S],\n) where {S<:Union{Int,ElementarySpace}}\n\nConstruct a CTMRG environment by specifying a corresponding InfinitePEPS, and the north, east, south and west virtual spaces of the environment. By default, the virtual spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to virtual space of the corresponding edge tensor for each direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{S, S, S}, NTuple{4, S}, NTuple{5, S}, NTuple{6, S}} where S<:Union{Int64, TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, ComplexF64], D_north::S, D_east::S, chi_north::S, [chi_east::S], [chi_south::S], [chi_west::S]; unitcell::Tuple{Int,Int}=(1, 1),\n) where {S<:Union{Int,ElementarySpace}}\n\nConstruct a CTMRG environment by specifying the north and east virtual spaces of the corresponding InfinitePEPS and the north, east, south and west virtual spaces of the environment. The PEPS unit cell can be specified by the unitcell keyword argument. By default, the virtual environment spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to virtual space of the corresponding edge tensor for each direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.EnlargedCorner","page":"Library","title":"PEPSKit.EnlargedCorner","text":"struct EnlargedCorner{Ct,E,A,A′}\n\nEnlarged CTMRG corner tensor storage.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.EnlargedCorner-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.EnlargedCorner","text":"EnlargedCorner(state, envs, coordinates)\n\nConstruct an enlarged corner with the correct row and column indices based on the given coordinates which are of the form (dir, row, col).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.FixedSVD","page":"Library","title":"PEPSKit.FixedSVD","text":"struct FixedSVD\n\nSVD struct containing a pre-computed decomposition or even multiple ones. The call to tsvd just returns the pre-computed U, S and V. In the reverse pass, the SVD adjoint is computed with these exact U, S, and V.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FixedSpaceTruncation","page":"Library","title":"PEPSKit.FixedSpaceTruncation","text":"FixedSpaceTruncation <: TensorKit.TruncationScheme\n\nCTMRG specific truncation scheme for tsvd which keeps the bond space on which the SVD is performed fixed. Since different environment directions and unit cell entries might have different spaces, this truncation style is different from TruncationSpace.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FullInfiniteProjector","page":"Library","title":"PEPSKit.FullInfiniteProjector","text":"struct FullInfiniteProjector{S,T}(; svd_alg=Defaults.svd_alg,\n                                  trscheme=Defaults.trscheme, verbosity=0)\n\nProjector algorithm implementing projectors from SVDing the full 4x4 CTMRG environment.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.GeomSum","page":"Library","title":"PEPSKit.GeomSum","text":"struct GeomSum(; maxiter=Defaults.fpgrad_maxiter, tol=Defaults.fpgrad_tol,\n               verbosity=0, iterscheme=Defaults.iterscheme) <: GradMode{iterscheme}\n\nGradient mode for CTMRG using explicit evaluation of the geometric sum.\n\nWith iterscheme the style of CTMRG iteration which is being differentiated can be chosen. If set to :fixed, the differentiated CTMRG iteration is assumed to have a pre-computed SVD of the environments with a fixed set of gauges. Alternatively, if set to :diffgauge, the differentiated iteration consists of a CTMRG iteration and a subsequent gauge fixing step, such that gauge_fix will also be differentiated everytime a CTMRG derivative is computed.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.HalfInfiniteEnv","page":"Library","title":"PEPSKit.HalfInfiniteEnv","text":"struct HalfInfiniteEnv{C,E,A,A′}\n\nHalf-infinite CTMRG environment tensor storage.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.HalfInfiniteEnv-Tuple{Any, Val{false}}","page":"Library","title":"PEPSKit.HalfInfiniteEnv","text":"(env::HalfInfiniteEnv)(x, ::Val{false}) \n(env::HalfInfiniteEnv)(x, ::Val{true})\n\nContract half-infinite environment with a vector x, such that the environment acts as a linear map or adjoint linear map on x if Val(true) or Val(false) is passed, respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.HalfInfiniteProjector","page":"Library","title":"PEPSKit.HalfInfiniteProjector","text":"struct HalfInfiniteProjector{S,T}(; svd_alg=Defaults.svd_alg,\n                                  trscheme=Defaults.trscheme, verbosity=0)\n\nProjector algorithm implementing projectors from SVDing the half-infinite CTMRG environment.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPO","page":"Library","title":"PEPSKit.InfinitePEPO","text":"struct InfinitePEPO{T<:PEPOTensor}\n\nRepresents an infinite projected entangled-pair operator (PEPO) on a 3D cubic lattice.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Tuple{T} where T<:(TensorKit.AbstractTensorMap{S, 2, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(A; unitcell=(1, 1, 1))\n\nCreate an InfinitePEPO by specifying a tensor and unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T<:(TensorKit.AbstractTensorMap{S, 2, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(A::AbstractArray{T, 3})\n\nAllow users to pass in an array of tensors.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{A}, Tuple{A, A}, Tuple{A, A, A}} where A<:(AbstractArray{<:TensorKit.ElementarySpace, 3})","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(f=randn, T=ComplexF64, Pspaces, Nspaces, Espaces)\n\nAllow users to pass in arrays of spaces.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(f=randn, T=ComplexF64, Pspace, Nspace, [Espace]; unitcell=(1,1,1))\n\nCreate an InfinitePEPO by specifying its spaces and unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS","page":"Library","title":"PEPSKit.InfinitePEPS","text":"struct InfinitePEPS{T<:PEPSTensor}\n\nRepresents an infinite projected entangled-pair state on a 2D square lattice.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Tuple{InfiniteWeightPEPS}","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(peps::InfiniteWeightPEPS)\n\nCreate InfinitePEPS from InfiniteWeightPEPS by absorbing bond weights into vertex tensors.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Tuple{T} where T<:(TensorKit.AbstractTensorMap{S, 1, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(A; unitcell=(1, 1))\n\nCreate an InfinitePEPS by specifying a tensor and unit cell.\n\nThe unit cell is labeled as a matrix which means that any tensor in the unit cell, regardless if PEPS tensor or environment tensor, is obtained by shifting the row and column index [r, c] by one, respectively:\n\n   |            |          |\n---C[r-1,c-1]---T[r-1,c]---T[r-1,c+1]---\n   |            ||         ||\n---T[r,c-1]=====AA[r,c]====AA[r,c+1]====\n   |            ||         ||\n---T[r+1,c-1]===AA[r+1,c]==AA[r+1,c+1]==\n   |            ||         ||\n\nThe unit cell has periodic boundary conditions, so [r, c] is indexed modulo the size of the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:(TensorKit.AbstractTensorMap{S, 1, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(A::AbstractMatrix{T})\n\nCreate an InfinitePEPS by specifying a matrix containing the PEPS tensors at each site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Union{Tuple{A}, Tuple{A, A, A}} where A<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(\n    f=randn, T=ComplexF64, Pspaces::A, Nspaces::A, [Espaces::A]\n) where {A<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\n\nCreate an InfinitePEPS by specifying the physical, north virtual and east virtual spaces of the PEPS tensor at each site in the unit cell as a matrix. Each individual space can be specified as either an Int or an ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S<:Union{Int64, TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(f=randn, T=ComplexF64, Pspace, Nspace, [Espace]; unitcell=(1,1))\n\nCreate an InfinitePEPS by specifying its physical, north and east spaces and unit cell. Spaces can be specified either via Int or via ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteSquare","page":"Library","title":"PEPSKit.InfiniteSquare","text":"InfiniteSquare(Nrows::Integer=1, Ncols::Integer=1)\n\nInfinite square lattice with a unit cell of size (Nrows, Ncols).\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPO","page":"Library","title":"PEPSKit.InfiniteTransferPEPO","text":"InfiniteTransferPEPO{T,O}\n\nRepresents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the expectation value of an InfinitePEPO between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any, Any}","page":"Library","title":"PEPSKit.InfiniteTransferPEPO","text":"InfiniteTransferPEPO(T::InfinitePEPS, O::InfinitePEPO, dir, row)\n\nConstructs a transfer operator corresponding to a single row of a partition function representing the expectation value of O for the state T. The partition function is first rotated such that the direction dir faces north, after which its rowth row from the north is selected.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPS","page":"Library","title":"PEPSKit.InfiniteTransferPEPS","text":"InfiniteTransferPEPS{T}\n\nRepresents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the overlap between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPS-Tuple{InfinitePEPS, Any, Any}","page":"Library","title":"PEPSKit.InfiniteTransferPEPS","text":"InfiniteTransferPEPS(T::InfinitePEPS, dir, row)\n\nConstructs a transfer operator corresponding to a single row of a partition function representing the norm of the state T. The partition function is first rotated such that the direction dir faces north, after which its rowth row from the north is selected.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteWeightPEPS","page":"Library","title":"PEPSKit.InfiniteWeightPEPS","text":"struct InfiniteWeightPEPS{T<:PEPSTensor,E<:PEPSWeight} <: AbstractPEPS\n\nRepresents an infinite projected entangled-pair state on a 2D square lattice consisting of vertex tensors and bond weights.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteWeightPEPS-Union{Tuple{E}, Tuple{T}, Tuple{Matrix{T}, Vararg{Matrix{E}}}} where {T<:(TensorKit.AbstractTensorMap{S, 1, 4} where S<:TensorKit.ElementarySpace), E<:(TensorKit.AbstractTensorMap{S, 1, 1} where S<:TensorKit.ElementarySpace)}","page":"Library","title":"PEPSKit.InfiniteWeightPEPS","text":"InfiniteWeightPEPS(\n    vertices::Matrix{T}, weight_mats::Matrix{E}...\n) where {T<:PEPSTensor,E<:PEPSWeight}\n\nCreate an InfiniteWeightPEPS from matrices of vertex tensors, and separate matrices of weights on each type of bond at all locations in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteWeightPEPS-Union{Tuple{S}, Tuple{Any, Any, S, S}, Tuple{Any, Any, S, S, S}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.InfiniteWeightPEPS","text":"InfiniteWeightPEPS(\n    f, T, Pspace::S, Nspace::S, Espace::S=Nspace; unitcell::Tuple{Int,Int}=(1, 1)\n) where {S<:ElementarySpace}\n\nCreate an InfiniteWeightPEPS by specifying its physical, north and east spaces (as ElementarySpaces) and unit cell size. Use T to specify the element type of the vertex tensors.  Bond weights are initialized as identity matrices of element type Float64. \n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.IterSVD","page":"Library","title":"PEPSKit.IterSVD","text":"struct IterSVD(; alg=KrylovKit.GKL(), fallback_threshold = Inf)\n\nIterative SVD solver based on KrylovKit's GKL algorithm, adapted to (symmetric) tensors. The number of targeted singular values is set via the TruncationSpace in ProjectorAlg. In particular, this make it possible to specify the targeted singular values block-wise. In case the symmetry block is too small as compared to the number of singular values, or the iterative SVD didn't converge, the algorithm falls back to a dense SVD.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.LinSolver","page":"Library","title":"PEPSKit.LinSolver","text":"struct LinSolver(; solver=KrylovKit.GMRES(), iterscheme=Defaults.iterscheme) <: GradMode{iterscheme}\n\nGradient mode wrapper around KrylovKit.LinearSolver for solving the gradient linear problem using iterative solvers.\n\nWith iterscheme the style of CTMRG iteration which is being differentiated can be chosen. If set to :fixed, the differentiated CTMRG iteration is assumed to have a pre-computed SVD of the environments with a fixed set of gauges. Alternatively, if set to :diffgauge, the differentiated iteration consists of a CTMRG iteration and a subsequent gauge fixing step, such that gauge_fix will also be differentiated everytime a CTMRG derivative is computed.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.LocalOperator","page":"Library","title":"PEPSKit.LocalOperator","text":"struct LocalOperator{T<:Tuple,S}\n\nA sum of local operators acting on a lattice. The lattice is stored as a matrix of vector spaces, and the terms are stored as a tuple of pairs of indices and operators.\n\nFields\n\nlattice::Matrix{S}: The lattice on which the operator acts.\nterms::T: The terms of the operator, stored as a tuple of pairs of indices and operators.\n\nConstructors\n\nLocalOperator(lattice::Matrix{S}, terms::Pair...)\nLocalOperator{T,S}(lattice::Matrix{S}, terms::T) where {T,S} # expert mode\n\nExamples\n\nlattice = fill(ℂ^2, 1, 1) # single-site unitcell\nO1 = LocalOperator(lattice, ((1, 1),) => σx, ((1, 1), (1, 2)) => σx ⊗ σx, ((1, 1), (2, 1)) => σx ⊗ σx)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ManualIter","page":"Library","title":"PEPSKit.ManualIter","text":"struct ManualIter(; maxiter=Defaults.fpgrad_maxiter, tol=Defaults.fpgrad_tol,\n                  verbosity=0, iterscheme=Defaults.iterscheme) <: GradMode{iterscheme}\n\nGradient mode for CTMRG using manual iteration to solve the linear problem.\n\nWith iterscheme the style of CTMRG iteration which is being differentiated can be chosen. If set to :fixed, the differentiated CTMRG iteration is assumed to have a pre-computed SVD of the environments with a fixed set of gauges. Alternatively, if set to :diffgauge, the differentiated iteration consists of a CTMRG iteration and a subsequent gauge fixing step, such that gauge_fix will also be differentiated everytime a CTMRG derivative is computed.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.NonTruncSVDAdjoint","page":"Library","title":"PEPSKit.NonTruncSVDAdjoint","text":"struct NonTruncAdjoint\n\nOld SVD adjoint that does not account for the truncated part of truncated SVDs.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPOTensor","page":"Library","title":"PEPSKit.PEPOTensor","text":"const PEPOTensor{S}\n\nDefault type for PEPO tensors with a single incoming and outgoing physical index, and 4 virtual indices, conventionally ordered as: O : P ⊗ P' ← N ⊗ E ⊗ S ⊗ W.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSOptimize","page":"Library","title":"PEPSKit.PEPSOptimize","text":"PEPSOptimize{G}(; boundary_alg=Defaults.ctmrg_alg, optimizer::OptimKit.OptimizationAlgorithm=Defaults.optimizer\n                reuse_env::Bool=true, gradient_alg::G=Defaults.gradient_alg)\n\nAlgorithm struct that represent PEPS ground-state optimization using AD. Set the algorithm to contract the infinite PEPS in boundary_alg; currently only CTMRGAlgorithms are supported. The optimizer computes the gradient directions based on the CTMRG gradient and updates the PEPS parameters. In this optimization, the CTMRG runs can be started on the converged environments of the previous optimizer step by setting reuse_env to true. Otherwise a random environment is used at each step. The CTMRG gradient itself is computed using the gradient_alg algorithm.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSTensor","page":"Library","title":"PEPSKit.PEPSTensor","text":"const PEPSTensor{S}\n\nDefault type for PEPS tensors with a single physical index, and 4 virtual indices, conventionally ordered as: T  P  N  E  S  W. Here, P, N, E, S and W denote the physics, north, east, south and west spaces, respectively.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSTensor-Union{Tuple{S}, Tuple{T}, Tuple{Any, Type{T}, S, S}, Tuple{Any, Type{T}, S, S, S}, Tuple{Any, Type{T}, Vararg{S, 4}}, Tuple{Any, Type{T}, Vararg{S, 5}}} where {T, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.PEPSTensor","text":"PEPSTensor(f, ::Type{T}, Pspace::S, Nspace::S,\n           [Espace::S], [Sspace::S], [Wspace::S]) where {T,S<:ElementarySpace}\nPEPSTensor(f, ::Type{T}, Pspace::Int, Nspace::Int,\n           [Espace::Int], [Sspace::Int], [Wspace::Int]) where {T}\n\nConstruct a PEPS tensor based on the physical, north, east, west and south spaces. Alternatively, only the space dimensions can be provided and ℂ is assumed as the field. The tensor elements are generated based on f and the element type is specified in T.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.PEPSWeight","page":"Library","title":"PEPSKit.PEPSWeight","text":"const PEPSWeight{S}\n\nDefault type for PEPS bond weights with 2 virtual indices, conventionally ordered as: wt  WS  EN.  WS, EN denote the west/south, east/north spaces for x/y-weights on the square lattice, respectively.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ProjectorAlgorithm","page":"Library","title":"PEPSKit.ProjectorAlgorithm","text":"ProjectorAlgorithm\n\nAbstract super type for all CTMRG projector algorithms.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ReflectDepth","page":"Library","title":"PEPSKit.ReflectDepth","text":"struct ReflectDepth <: SymmetrizationStyle\n\nReflection symmmetrization along the horizontal axis, such that north and south are mirrored.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ReflectWidth","page":"Library","title":"PEPSKit.ReflectWidth","text":"struct ReflectWidth <: SymmetrizationStyle\n\nReflection symmmetrization along the vertical axis, such that east and west are mirrored.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.Rotate","page":"Library","title":"PEPSKit.Rotate","text":"struct Rotate <: SymmetrizationStyle\n\nRotation symmmetrization leaving the object invariant under π/2 rotations.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.RotateReflect","page":"Library","title":"PEPSKit.RotateReflect","text":"struct RotateReflect <: SymmetrizationStyle\n\nFull reflection and rotation symmmetrization, such that reflection along the horizontal and vertical axis as well as π/2 rotations leave the object invariant.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SUWeight","page":"Library","title":"PEPSKit.SUWeight","text":"struct SUWeight{E<:PEPSWeight}\n\nSchmidt bond weights used in simple/cluster update. Weight elements are always real.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SVDAdjoint","page":"Library","title":"PEPSKit.SVDAdjoint","text":"struct SVDAdjoint(; fwd_alg=Defaults.fwd_alg, rrule_alg=Defaults.rrule_alg,\n                  broadening=nothing)\n\nWrapper for a SVD algorithm fwd_alg with a defined reverse rule rrule_alg. If isnothing(rrule_alg), Zygote differentiates the forward call automatically. In case of degenerate singular values, one might need a broadening scheme which removes the divergences from the adjoint.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SequentialCTMRG","page":"Library","title":"PEPSKit.SequentialCTMRG","text":"SequentialCTMRG(; tol=Defaults.ctmrg_tol, maxiter=Defaults.ctmrg_maxiter,\n                  miniter=Defaults.ctmrg_miniter, verbosity=0,\n                  projector_alg=typeof(Defaults.projector_alg),\n                  svd_alg=SVDAdjoint(), trscheme=FixedSpaceTruncation())\n\nCTMRG algorithm where the expansions and renormalization is performed sequentially column-wise. This is implemented as a growing and projecting step to the left, followed by a clockwise rotation (performed four times). The projectors are computed using projector_alg from svd_alg SVDs where the truncation scheme is set via trscheme.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SimpleUpdate","page":"Library","title":"PEPSKit.SimpleUpdate","text":"struct SimpleUpdate\n\nAlgorithm struct for simple update (SU) of infinite PEPS with bond weights. Each SU run is converged when the singular value difference becomes smaller than tol.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SimultaneousCTMRG","page":"Library","title":"PEPSKit.SimultaneousCTMRG","text":"SimultaneousCTMRG(; tol=Defaults.ctmrg_tol, maxiter=Defaults.ctmrg_maxiter,\n                  miniter=Defaults.ctmrg_miniter, verbosity=0,\n                  projector_alg=Defaults.projector_alg,\n                  svd_alg=SVDAdjoint(), trscheme=FixedSpaceTruncation())\n\nCTMRG algorithm where all sides are grown and renormalized at the same time. In particular, the projectors are applied to the corners from two sides simultaneously. The projectors are computed using projector_alg from svd_alg SVDs where the truncation scheme is set via  trscheme.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.TransferPEPOMultiline","page":"Library","title":"PEPSKit.TransferPEPOMultiline","text":"const TransferPEPOMultiline = MPSKit.Multiline{<:InfiniteTransferPEPO}\n\nType that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap of an InfinitePEPO between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.TransferPEPOMultiline-Tuple{InfinitePEPS, InfinitePEPO, Any}","page":"Library","title":"PEPSKit.TransferPEPOMultiline","text":"TransferPEPOMultiline(T::InfinitePEPS, O::InfinitePEPO, dir)\n\nConstruct a multi-row transfer operator corresponding to the partition function representing the expectation value of O for the state T. The partition function is first rotated such that the direction dir faces north.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.TransferPEPSMultiline","page":"Library","title":"PEPSKit.TransferPEPSMultiline","text":"const TransferPEPSMultiline = MPSKit.Multiline{<:InfiniteTransferPEPS}\n\nType that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.TransferPEPSMultiline-Tuple{InfinitePEPS, Any}","page":"Library","title":"PEPSKit.TransferPEPSMultiline","text":"TransferPEPSMultiline(T::InfinitePEPS, dir)\n\nConstruct a multi-row transfer operator corresponding to the partition function representing the norm of the state T. The partition function is first rotated such that the direction dir faces north.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TensorKit.TensorMap-Tuple{PEPSKit.EnlargedCorner, Int64}","page":"Library","title":"TensorKit.TensorMap","text":"TensorKit.TensorMap(Q::EnlargedCorner, dir::Int)\n\nInstantiate enlarged corner as TensorMap where dir selects the correct contraction direction, i.e. the way the environment and PEPS tensors connect.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TensorKit.TensorMap-Tuple{PEPSKit.HalfInfiniteEnv}","page":"Library","title":"TensorKit.TensorMap","text":"TensorKit.TensorMap(env::HalfInfiniteEnv)\n\nInstantiate half-infinite environment as TensorMap explicitly.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.correlation_length-Tuple{InfinitePEPS, CTMRGEnv}","page":"Library","title":"MPSKit.correlation_length","text":"correlation_length(peps::InfinitePEPS, env::CTMRGEnv; num_vals=2)\n\nCompute the PEPS correlation length based on the horizontal and vertical transfer matrices. Additionally the (normalized) eigenvalue spectrum is returned. Specify the number of computed eigenvalues with num_vals.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.expectation_value-Tuple{Any, Any}","page":"Library","title":"MPSKit.expectation_value","text":"MPSKit.expectation_value(st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO})\nMPSKit.expectation_value(st::MPSMultiline, op::Union{TransferPEPSMultiline,TransferPEPOMultiline})\n\nCompute expectation value of the transfer operator op for the state st for each site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.leading_boundary-Tuple{Any, Any, Any}","page":"Library","title":"MPSKit.leading_boundary","text":"MPSKit.leading_boundary(\n    st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO}, alg, [envs]\n)\nMPSKit.leading_boundary(\n    st::MPSMulitline, op::Union{TransferPEPSMultiline,TransferPEPOMultiline}, alg, [envs]\n)\n\nApproximate the leading boundary MPS eigenvector for the transfer operator op using st as initial guess.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.leading_boundary-Tuple{Any, PEPSKit.CTMRGAlgorithm}","page":"Library","title":"MPSKit.leading_boundary","text":"MPSKit.leading_boundary([envinit], state, alg::CTMRGAlgorithm)\n\nContract state using CTMRG and return the CTM environment. Per default, a random initial environment is used.\n\nEach CTMRG run is converged up to alg.tol where the singular value convergence of the corners and edges is checked. The maximal and minimal number of CTMRG iterations is set with alg.maxiter and alg.miniter.\n\nDifferent levels of output information are printed depending on alg.verbosity, where 0 suppresses all output, 1 only prints warnings, 2 gives information at the start and end, and 3 prints information every iteration.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._mirror_antidiag_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S<:Union{Tuple{Int64, Int64}, CartesianIndex{2}}","page":"Library","title":"PEPSKit._mirror_antidiag_site","text":"_mirror_antidiag_site(\n    site::S, (Nrow, Ncol)::NTuple{2,Int}\n) where {S<:Union{CartesianIndex{2},NTuple{2,Int}}}\n\nGet the position of site after reflection about the anti-diagonal line.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._rot180_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S<:Union{Tuple{Int64, Int64}, CartesianIndex{2}}","page":"Library","title":"PEPSKit._rot180_site","text":"_rot180_site(\n    site::S, (Nrow, Ncol)::NTuple{2,Int}\n) where {S<:Union{CartesianIndex{2},NTuple{2,Int}}}\n\nGet the position of site after rotation by 180 degrees.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._rotl90_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S<:Union{Tuple{Int64, Int64}, CartesianIndex{2}}","page":"Library","title":"PEPSKit._rotl90_site","text":"_rotl90_site(\n    site::S, (Nrow, Ncol)::NTuple{2,Int}\n) where {S<:Union{CartesianIndex{2},NTuple{2,Int}}}\n\nGet the position of site after counter-clockwise (left) rotation by 90 degrees.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._rotr90_site-Union{Tuple{S}, Tuple{S, Tuple{Int64, Int64}}} where S<:Union{Tuple{Int64, Int64}, CartesianIndex{2}}","page":"Library","title":"PEPSKit._rotr90_site","text":"_rotr90_site(\n    site::S, (Nrow, Ncol)::NTuple{2,Int}\n) where {S<:Union{CartesianIndex{2},NTuple{2,Int}}}\n\nGet the position of site after clockwise (right) rotation by 90 degrees.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._rrule-Tuple{Nothing, ChainRulesCore.RuleConfig, Any, Vararg{Any}}","page":"Library","title":"PEPSKit._rrule","text":"_rrule(alg_rrule, config, f, args...; kwargs...) -> ∂f, ∂args...\n\nCustomize the pullback of a function f. This function can specialize on its first argument in order to have multiple implementations for a pullback. If no specialization is needed, the default alg_rrule=nothing results in the default AD pullback.\n\nwarning: Warning\nNo tangent is expected for the alg_rrule argument\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._su_bondx!-Union{Tuple{S}, Tuple{Int64, Int64, TensorKit.AbstractTensorMap{S, 2, 2}, InfiniteWeightPEPS, SimpleUpdate}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit._su_bondx!","text":"subondx!(row::Int, col::Int, gate::AbstractTensorMap{S,2,2},            peps::InfiniteWeightPEPS, alg::SimpleUpdate) where {S<:ElementarySpace}\n\nSimple update of the x-bond peps.weights[1,r,c].\n\n                [2,r,c]             [2,r,c+1]\n                ↓                   ↓\n    [1,r,c-1] ← T[r,c] ← [1,r,c] ←- T[r,c+1] ← [1,r,c+1]\n                ↓                   ↓\n                [2,r+1,c]           [2,r+1,c+1]\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.absorb_s-Tuple{TensorKit.AbstractTensorMap, TensorKit.AbstractTensorMap, TensorKit.AbstractTensorMap}","page":"Library","title":"PEPSKit.absorb_s","text":"absorb_s(u::AbstractTensorMap, s::AbstractTensorMap, vh::AbstractTensorMap)\n\nGiven tsvd result u, s and vh, absorb singular values s into u and vh by:\n\n    u -> u * sqrt(s), vh -> sqrt(s) * vh\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.absorb_weight-Union{Tuple{T}, Tuple{T, Int64, Int64, Int64, SUWeight}} where T<:(TensorKit.AbstractTensorMap{S, 1, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.absorb_weight","text":"absorb_weight(t::T, row::Int, col::Int, ax::Int, weights::SUWeight;\n              sqrtwt::Bool=false, invwt::Bool=false) where {T<:PEPSTensor}\n\nAbsorb or remove environment weight on axis ax of vertex tensor t  known to be located at position (row, col) in the unit cell.  Weights around the tensor at (row, col) are\n\n                    ↓\n                [2,r,c]\n                    ↓\n    ← [1,r,c-1] ← T[r,c] ← [1,r,c] ←\n                    ↓\n                [1,r+1,c]\n                    ↓\n\nArguments\n\nt::T: The vertex tensor to which the weight will be absorbed. The first axis of t should be the physical axis. \nrow::Int: The row index specifying the position in the tensor network.\ncol::Int: The column index specifying the position in the tensor network.\nax::Int: The axis along which the weight is absorbed.\nweights::SUWeight: The weight object to absorb into the tensor.\nsqrtwt::Bool=false (optional): If true, the square root of the weight is absorbed.\ninvwt::Bool=false (optional): If true, the inverse of the weight is absorbed.\n\nDetails\n\nThe optional kwargs sqrtwt and invwt allow taking the square root or the inverse of the weight before absorption. \n\nExamples\n\n# Absorb the weight into the 2nd axis of tensor at position (2, 3)\nabsorb_weight(t, 2, 3, 2, weights)\n\n# Absorb the square root of the weight into the tensor\nabsorb_weight(t, 2, 3, 2, weights; sqrtwt=true)\n\n# Absorb the inverse of (i.e. remove) the weight into the tensor\nabsorb_weight(t, 2, 3, 2, weights; invwt=true)\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.calc_convergence-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.calc_convergence","text":"calc_convergence(envs, CSold, TSold)\n\nGiven a new environment envs and the singular values of previous corners and edges CSold and TSold, compute the maximal singular value distance.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.calc_elementwise_convergence-Tuple{CTMRGEnv, CTMRGEnv}","page":"Library","title":"PEPSKit.calc_elementwise_convergence","text":"calc_elementwise_convergence(envfinal, envfix; atol=1e-6)\n\nCheck if the element-wise difference of the corner and edge tensors of the final and fixed CTMRG environments are below some tolerance.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.checklattice-Tuple","page":"Library","title":"PEPSKit.checklattice","text":"checklattice(Bool, args...)\nchecklattice(args...)\n\nHelper function for checking lattice compatibility. The first version returns a boolean, while the second version throws an error if the lattices do not match.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.compute_projector-Tuple{Any, Any, HalfInfiniteProjector}","page":"Library","title":"PEPSKit.compute_projector","text":"compute_projector(enlarged_corners, coordinate, alg::ProjectorAlgorithm)\n\nDetermine left and right projectors at the bond given determined by the enlarged corners and the given coordinate using the specified alg.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_localnorm-Union{Tuple{N}, Tuple{NTuple{N, CartesianIndex{2}}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where N","page":"Library","title":"PEPSKit.contract_localnorm","text":"contract_localnorm(inds, peps, env)\n\nContract a local norm of the PEPS peps around indices inds.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_localoperator-Union{Tuple{N}, Tuple{S}, Tuple{NTuple{N, CartesianIndex{2}}, TensorKit.AbstractTensorMap{S, N, N}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where {S, N}","page":"Library","title":"PEPSKit.contract_localoperator","text":"contract_localoperator(inds, O, peps, env)\n\nContract a local operator O on the PEPS peps at the indices inds using the environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_projectors-NTuple{5, Any}","page":"Library","title":"PEPSKit.contract_projectors","text":"contract_projectors(U, S, V, Q, Q_next)\n\nCompute projectors based on a SVD of Q * Q_next, where the inverse square root isqS of the singular values is computed.\n\nLeft projector:\n\n    -- |~~~~~~| -- |~~|\n       |Q_next|    |V'| -- isqS --\n    == |~~~~~~| == |~~|\n\nRight projector:\n\n               |~~| -- |~~~| --\n    -- isqS -- |U'|    | Q |\n               |~~| == |~~~| ==\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ctmrg_iteration-Tuple{Any, Any, PEPSKit.CTMRGAlgorithm}","page":"Library","title":"PEPSKit.ctmrg_iteration","text":"ctmrg_iteration(state, env, alg::CTMRGAlgorithm) -> env′, info\n\nPerform a single CTMRG iteration in which all directions are being grown and renormalized.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.dtmap-Tuple","page":"Library","title":"PEPSKit.dtmap","text":"dtmap(args...; kwargs...)\n\nDifferentiable wrapper around OhMyThreads.tmap.\n\nAll calls of dtmap inside of PEPSKit use the threading scheduler stored inside Defaults.scheduler which can be modified using set_scheduler!.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.eachcoordinate","page":"Library","title":"PEPSKit.eachcoordinate","text":"eachcoordinate(x, dirs=1:4)\n\nEnumerate all (dir, row, col) pairs.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.enlarge_northeast_corner","page":"Library","title":"PEPSKit.enlarge_northeast_corner","text":"enlarge_northeast_corner((row, col), envs, ket, bra)\nenlarge_northeast_corner(E_north, C_northeast, E_east, ket, bra)\n\nContract the enlarged northeast corner of the CTMRG environment, either by specifying the coordinates, environments and state, or by directly providing the tensors.\n\n    -- E_north -- C_northeast\n          ||            |\n    == ket-bra ==    E_east\n          ||            |\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.enlarge_northwest_corner","page":"Library","title":"PEPSKit.enlarge_northwest_corner","text":"enlarge_northwest_corner((row, col), envs, ket, bra)\nenlarge_northwest_corner(E_west, C_northwest, E_north, ket, bra)\n\nContract the enlarged northwest corner of the CTMRG environment, either by specifying the coordinates, environments and state, or by directly providing the tensors.\n\n    C_northwest -- E_north --\n         |            ||\n      E_west    == ket-bra ==\n         |            ||\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.enlarge_southeast_corner","page":"Library","title":"PEPSKit.enlarge_southeast_corner","text":"enlarge_southeast_corner((row, col), envs, ket, bra)\nenlarge_southeast_corner(E_east, C_southeast, E_south, ket, bra)\n\nContract the enlarged southeast corner of the CTMRG environment, either by specifying the coordinates, environments and state, or by directly providing the tensors.\n\n          ||            |\n    == ket-bra ==    E_east\n          ||            |\n    -- E_south -- C_southeast\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.enlarge_southwest_corner","page":"Library","title":"PEPSKit.enlarge_southwest_corner","text":"enlarge_southwest_corner((row, col), envs, ket, bra)\nenlarge_southwest_corner(E_south, C_southwest, E_west, ket, bra)\n\nContract the enlarged southwest corner of the CTMRG environment, either by specifying the coordinates, environments and state, or by directly providing the tensors.\n\n          |           ||      \n       E_west   == ket-bra == \n          |           ||      \n    C_southwest -- E_south -- \n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.fix_gauge_corner-Tuple{TensorKit.AbstractTensorMap{S, 1, 1} where S, TensorKit.AbstractTensorMap{S, 1, 1} where S, TensorKit.AbstractTensorMap{S, 1, 1} where S}","page":"Library","title":"PEPSKit.fix_gauge_corner","text":"fix_gauge_corner(corner, σ_in, σ_out)\n\nMultiply corner tensor with incoming and outgoing gauge signs.\n\n    corner -- σ_out --\n      |  \n     σ_in\n      |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_east_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_east_edge","text":"fix_gauge_east_edge((row, col), envs, signs)\n\nApply fix_gauge_edge to the east edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_east_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_east_left_vecs","text":"fix_gauge_east_left_vecs((row, col), U, signs)\n\nMultiply east left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_east_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_east_right_vecs","text":"fix_gauge_east_right_vecs((row, col), V, signs)\n\nMultiply east right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_edge-Tuple{TensorKit.AbstractTensorMap{S, 3, 1} where S, TensorKit.AbstractTensorMap{S, 1, 1} where S, TensorKit.AbstractTensorMap{S, 1, 1} where S}","page":"Library","title":"PEPSKit.fix_gauge_edge","text":"fix_gauge_edge(edge, σ_in, σ_out)\n\nMultiply edge tensor with incoming and outgoing gauge signs.\n\n    -- σ_in -- edge -- σ_out --\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_north_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_north_edge","text":"fix_gauge_north_edge((row, col), envs, signs)\n\nApply fix_gauge_edge to the north edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_north_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_north_left_vecs","text":"fix_gauge_north_left_vecs((row, col), U, signs)\n\nMultiply north left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_north_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_north_right_vecs","text":"fix_gauge_north_right_vecs((row, col), V, signs)\n\nMultiply north right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_northeast_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_northeast_corner","text":"fix_gauge_northeast_corner((row, col), envs, signs)\n\nApply fix_gauge_corner to the northeast corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_northwest_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_northwest_corner","text":"fix_gauge_northwest_corner((row, col), envs, signs)\n\nApply fix_gauge_corner to the northwest corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_south_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_south_edge","text":"fix_gauge_south_edge((row, col), envs, signs)\n\nApply fix_gauge_edge to the south edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_south_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_south_left_vecs","text":"fix_gauge_south_left_vecs((row, col), U, signs)\n\nMultiply south left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_south_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_south_right_vecs","text":"fix_gauge_south_right_vecs((row, col), V, signs)\n\nMultiply south right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_southeast_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_southeast_corner","text":"fix_gauge_southeast_corner((row, col), envs, signs)\n\nApply fix_gauge_corner to the southeast corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_southwest_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_southwest_corner","text":"fix_gauge_southwest_corner((row, col), envs, signs)\n\nApply fix_gauge_corner to the southwest corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_west_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_west_edge","text":"fix_gauge_south_edge((row, col), envs, signs)\n\nApply fix_gauge_edge to the west edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_west_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_west_left_vecs","text":"fix_gauge_west_left_vecs((row, col), U, signs)\n\nMultiply west left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_west_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_west_right_vecs","text":"fix_gauge_west((row, col), V, signs)\n\nMultiply west right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fixedpoint-Union{Tuple{F}, Tuple{InfinitePEPS{F}, Any, PEPSOptimize}, Tuple{InfinitePEPS{F}, Any, PEPSOptimize, CTMRGEnv}} where F","page":"Library","title":"PEPSKit.fixedpoint","text":"fixedpoint(ψ₀::InfinitePEPS{T}, H, alg::PEPSOptimize, [env₀::CTMRGEnv];\n           finalize!=OptimKit._finalize!, symmetrization=nothing) where {T}\n\nOptimize ψ₀ with respect to the Hamiltonian H according to the parameters supplied in alg. The initial environment env₀ serves as an initial guess for the first CTMRG run. By default, a random initial environment is used.\n\nThe finalize! kwarg can be used to insert a function call after each optimization step by utilizing the finalize! kwarg of OptimKit.optimize. The function maps (peps, envs), f, g = finalize!((peps, envs), f, g, numiter). The symmetrization kwarg accepts nothing or a SymmetrizationStyle, in which case the PEPS and PEPS gradient are symmetrized after each optimization iteration. Note that this requires a symmmetric ψ₀ and env₀ to converge properly.\n\nThe function returns a NamedTuple which contains the following entries:\n\npeps: final InfinitePEPS\nenv: CTMRGEnv corresponding to the final PEPS\nE: final energy\nE_history: convergence history of the energy function\ngrad: final energy gradient\ngradnorm_history: convergence history of the energy gradient norms\nnumfg: total number of calls to the energy function\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fpgrad","page":"Library","title":"PEPSKit.fpgrad","text":"fpgrad(∂F∂x, ∂f∂x, ∂f∂A, y0, alg)\n\nCompute the gradient of the cost function for CTMRG by solving the following equation:\n\ndx = ∑ₙ (∂f∂x)ⁿ ∂f∂A dA = (1 - ∂f∂x)⁻¹ ∂f∂A dA\n\nwhere ∂F∂x is the gradient of the cost function with respect to the PEPS tensors, ∂f∂x is the partial gradient of the CTMRG iteration with respect to the environment tensors, ∂f∂A is the partial gradient of the CTMRG iteration with respect to the PEPS tensors, and y0 is the initial guess for the fixed-point iteration. The function returns the gradient dx of the fixed-point iteration.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.gauge_fix-Union{Tuple{T}, Tuple{C}, Tuple{CTMRGEnv{C, T}, CTMRGEnv{C, T}}} where {C, T}","page":"Library","title":"PEPSKit.gauge_fix","text":"gauge_fix(envprev::CTMRGEnv{C,T}, envfinal::CTMRGEnv{C,T}) where {C,T}\n\nFix the gauge of envfinal based on the previous environment envprev. This assumes that the envfinal is the result of one CTMRG iteration on envprev. Given that the CTMRG run is converged, the returned environment will be element-wise converged to envprev.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.get_gate-Tuple{Float64, LocalOperator}","page":"Library","title":"PEPSKit.get_gate","text":"get_gate(dt::Float64, H::LocalOperator)\n\nCompute exp(-dt * H) from the nearest neighbor Hamiltonian H.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.get_gateterm-Tuple{LocalOperator, Tuple{CartesianIndex{2}, CartesianIndex{2}}}","page":"Library","title":"PEPSKit.get_gateterm","text":"get_gateterm(gate::LocalOperator, bond::NTuple{2,CartesianIndex{2}})\n\nGet the term of a 2-site gate acting on a certain bond. Input gate should only include one term for each nearest neighbor bond.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.half_infinite_environment-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{S, 3, 3}, TensorKit.AbstractTensorMap{S, 3, 3}}} where S","page":"Library","title":"PEPSKit.half_infinite_environment","text":"half_infinite_environment(quadrant1::AbstractTensorMap{S,3,3}, quadrant2::AbstractTensorMap{S,3,3})\nhalf_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4,\n                          ket_1::P, ket_2::P, bra_1::P=ket_1, bra_2::P=ket_2) where {P<:PEPSTensor}\nhalf_infinite_environment(C_1, C_2, E_1, E_2, E_3, E_4, x,\n                          ket_1::P, ket_2::P, bra_1::P=ket_1, bra_2::P=ket_2) where {P<:PEPSTensor}\nhalf_infinite_environment(x, C_1, C_2, E_1, E_2, E_3, E_4,\n                          ket_1::P, ket_2::P, bra_1::P=ket_1, bra_2::P=ket_2) where {P<:PEPSTensor}\n\nContract two quadrants (enlarged corners) to form a half-infinite environment.\n\n    |~~~~~~~~~| -- |~~~~~~~~~|\n    |quadrant1|    |quadrant2|\n    |~~~~~~~~~| == |~~~~~~~~~|\n      |    ||        ||    |\n\nThe environment can also be contracted directly from all its constituent tensors.\n\n    C_1 --  E_2      --  E_3      -- C_2\n     |       ||          ||           | \n    E_1 == ket_bra_1 == ket_bra_2 == E_4\n     |       ||          ||           |\n\nAlternatively, contract the environment with a vector x acting on it\n\n    C_1 --  E_2      --  E_3      -- C_2\n     |       ||          ||           | \n    E_1 == ket_bra_1 == ket_bra_2 == E_4\n     |       ||          ||           |\n                         [~~~~~~x~~~~~~]\n\nor contract the adjoint environment with x, e.g. as needed for iterative solvers.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.hook_pullback-Tuple{Any, Vararg{Any}}","page":"Library","title":"PEPSKit.hook_pullback","text":"hook_pullback(f, args...; alg_rrule=nothing, kwargs...)\n\nWrapper function to customize the pullback of a function f. This function is equivalent to f(args...; kwargs...), but the pullback can be customized by implementing the following function:\n\n_rrule(alg_rrule, config, f, args...; kwargs...) -> NoTangent(), ∂f, ∂args...\n\nThis function can specialize on its first argument in order to customize the pullback. If no specialization is needed, the default alg_rrule=nothing results in the default AD pullback.\n\nSee also _rrule.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.initializeMPS-Union{Tuple{S}, Tuple{InfiniteTransferPEPS, AbstractVector{S}}} where S","page":"Library","title":"PEPSKit.initializeMPS","text":"initializeMPS(\n    O::Union{InfiniteTransferPEPS,InfiniteTransferPEPO},\n    virtualspaces::AbstractArray{<:ElementarySpace,1}\n)\ninitializeMPS(\n    O::Union{TransferPEPSMultiline,TransferPEPOMultiline},\n    virtualspaces::AbstractArray{<:ElementarySpace,2}\n)\n\nInialize a boundary MPS for the transfer operator O by specifying an array of virtual spaces consistent with the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.is_equivalent-Tuple{Tuple{CartesianIndex{2}, CartesianIndex{2}}, Tuple{CartesianIndex{2}, CartesianIndex{2}}, Tuple{Int64, Int64}}","page":"Library","title":"PEPSKit.is_equivalent","text":"is_equivalent(bond1::NTuple{2,CartesianIndex{2}}, bond2::NTuple{2,CartesianIndex{2}}, (Nrow, Ncol)::NTuple{2,Int})\n\nCheck if two 2-site bonds are related by a (periodic) lattice translation.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.j1_j2-Tuple{InfiniteSquare}","page":"Library","title":"PEPSKit.j1_j2","text":"j1_j2([elt::Type{T}], [symm::Type{S}], [lattice::InfiniteSquare];\n      J1=1.0, J2=1.0, spin=1//2, sublattice=true)\n\nSquare lattice J₁-J₂ model. The sublattice kwarg enables a single site unit cell via a sublattice rotation.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.left_projector","page":"Library","title":"PEPSKit.left_projector","text":"left_projector(E_1, C, E_2, V, isqS, ket::PEPSTensor, bra::PEPSTensor=ket)\n\nContract the CTMRG left projector with the higher-dimensional subspace facing to the left.\n\n     C  --  E_2    -- |~~|\n     |       ||       |V'| -- isqS --\n    E_1 == ket-bra == |~~|\n     |       ||\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.mirror_antidiag-Tuple{AbstractMatrix}","page":"Library","title":"PEPSKit.mirror_antidiag","text":"mirror_antidiag(arr::AbstractMatrix)\n\nMirror a matrix by its anti-diagonal line (the 45 degree line through the lower-left corner).\n\nThe element originally at [r, c] is moved [Nc-c+1, Nr-r+1], i.e. the element now at [r, c] was originally at [Nr-c+1, Nc-r+1]\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.mirror_antidiag-Tuple{InfiniteWeightPEPS}","page":"Library","title":"PEPSKit.mirror_antidiag","text":"mirror_antidiag(peps::InfiniteWeightPEPS)\n\nMirror the unit cell of an iPEPS with weights by its anti-diagonal line.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.mirror_antidiag-Tuple{LocalOperator}","page":"Library","title":"PEPSKit.mirror_antidiag","text":"mirror_antidiag(H::LocalOperator)\n\nMirror a LocalOperator across the anti-diagonal axis of its lattice.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.nearest_neighbour_hamiltonian-Union{Tuple{S}, Tuple{Matrix{S}, TensorKit.AbstractTensorMap{S, 2, 2}}} where S","page":"Library","title":"PEPSKit.nearest_neighbour_hamiltonian","text":"nearest_neighbour_hamiltonian(\n    lattice::Matrix{S}, h::AbstractTensorMap{S,2,2}\n) where {S}\n\nCreate a nearest neighbor LocalOperator by specifying the 2-site interaction term h which acts both in horizontal and vertical direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.product_peps-Tuple","page":"Library","title":"PEPSKit.product_peps","text":"product_peps(peps_args...; unitcell=(1, 1), noise_amp=1e-2, state_vector=nothing)\n\nInitialize a normalized random product PEPS with noise. The given arguments are passed on to the InfinitePEPS constructor.\n\nThe noise intensity can be tuned with noise_amp. The product state coefficients can be specified using the state_vector kwarg in the form of a matrix of size unitcell containing vectors that match the PEPS physical dimensions. If nothing is provided, random Gaussian coefficients are used.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.pwave_superconductor-Tuple{InfiniteSquare}","page":"Library","title":"PEPSKit.pwave_superconductor","text":"pwave_superconductor(::Type{T}=ComplexF64; t=1, μ=2, Δ=1, unitcell=(1, 1))\n\nSquare lattice p-wave superconductor model.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_bottom_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.renormalize_bottom_corner","text":"renormalize_bottom_corner((r, c), envs, projectors)\n\nApply bottom projector to southwest corner and south edge.\n\n        | \n    [P_bottom]\n     |     ||\n     C --  E -- in\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_corner-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{S, 3, 3}, Any, Any}} where S","page":"Library","title":"PEPSKit.renormalize_corner","text":"renormalize_corner(quadrant::AbstractTensorMap{S,3,3}, P_left, P_right)\n\nApply projectors to each side of a quadrant.\n\n    |~~~~~~~~| -- |~~~~~~|\n    |quadrant|    |P_left| --\n    |~~~~~~~~| == |~~~~~~|\n     |    ||\n    [P_right]\n        |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_east_edge","page":"Library","title":"PEPSKit.renormalize_east_edge","text":"renormalize_east_edge((row, col), envs, P_top, P_bottom, ket, bra)\nrenormalize_east_edge(E_east, P_top, P_bottom, ket, bra)\n\nAbsorb a bra-ket pair into the east edge using the given projectors and environment tensors.\n\n            |\n     [~~P_bottom~~]\n      |         ||\n    E_east == ket-bra\n      |         ||\n     [~~~~P_top~~~]\n            |\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.renormalize_north_edge","page":"Library","title":"PEPSKit.renormalize_north_edge","text":"renormalize_north_edge((row, col), envs, P_left, P_right, ket, bra)\nrenormalize_north_edge(E_north, P_left, P_right, ket, bra)\n\nAbsorb a bra-ket pair into the north edge using the given projectors and environment tensors.\n\n       |~~~~~~| -- E_north -- |~~~~~~~| \n    -- |P_left|      ||       |P_right| --\n       |~~~~~~| == ket-bra == |~~~~~~~| \n\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.renormalize_northeast_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_northeast_corner","text":"renormalize_northeast_corner((row, col), enlarged_envs::CTMRGEnv, P_left, P_right)\nrenormalize_northwest_corner(quadrant::AbstractTensorMap{S,3,3}, P_left, P_right) where {S}\nrenormalize_northeast_corner(E_north, C_northeast, E_east, P_left, P_right, ket::PEPSTensor, bra::PEPSTensor=ket)\n\nApply renormalize_corner to the enlarged northeast corner. Alternatively, provide the constituent tensors and perform the complete contraction.\n\n       |~~~~~~~| --  E_north --  C_northeast\n    -- |P_right|       ||             |  \n       |~~~~~~~| ==  ket-bra ==     E_east\n                       ||             |\n                     [~~~~~~P_left~~~~~~]\n                              |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_northwest_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_northwest_corner","text":"renormalize_northwest_corner((row, col), enlarged_envs::CTMRGEnv, P_left, P_right)\nrenormalize_northwest_corner(quadrant::AbstractTensorMap{S,3,3}, P_left, P_right) where {S}\nrenormalize_northwest_corner(E_west, C_northwest, E_north, P_left, P_right, ket::PEPSTensor, bra::PEPSTensor=ket)\n\nApply renormalize_corner to the enlarged northwest corner. Alternatively, provide the constituent tensors and perform the complete contraction.\n\n    C_northwest -- E_north -- |~~~~~~|\n         |           ||       |P_left| --\n      E_west=   == ket-bra == |~~~~~~|\n         |           ||\n      [~~~~~P_right~~~~~]\n               |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_sequentially-Tuple{Int64, Any, Any, Any}","page":"Library","title":"PEPSKit.renormalize_sequentially","text":"renormalize_sequentially(col::Int, projectors, state, envs)\n\nRenormalize one column of the CTMRG environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_simultaneously-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_simultaneously","text":"renormalize_simultaneously(enlarged_corners, projectors, state, envs)\n\nRenormalize all enlarged corners and edges simultaneously.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_south_edge","page":"Library","title":"PEPSKit.renormalize_south_edge","text":"renormalize_south_edge((row, col), envs, P_left, P_right, ket, bra)\nrenormalize_south_edge(E_south, P_left, P_right, ket, bra)\n\nAbsorb a bra-ket pair into the south edge using the given projectors and environment tensors.\n\n       |~~~~~~~| == ket-bra == |~~~~~~| \n    -- |P_right|      ||       |P_left| --\n       |~~~~~~~| -- E_south -- |~~~~~~| \n\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.renormalize_southeast_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_southeast_corner","text":"renormalize_southeast_corner((row, col), enlarged_envs::CTMRGEnv, P_left, P_right)\nrenormalize_southeast_corner(quadrant::AbstractTensorMap{S,3,3}, P_left, P_right) where {S}\nrenormalize_southeast_corner(E_east, C_southeast, E_south, P_left, P_right, ket::PEPSTensor, bra::PEPSTensor=ket)\n\nApply renormalize_corner to the enlarged southeast corner. Alternatively, provide the constituent tensors and perform the complete contraction.\n\n                            |\n                   [~~~~~P_right~~~~~]\n                      ||           |\n       |~~~~~~| == ket-bra ==    E_east\n    -- |P_left|       ||           |\n       |~~~~~~| -- E_south -- C_southeast\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_southwest_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_southwest_corner","text":"renormalize_southwest_corner((row, col), enlarged_envs::CTMRGEnv, P_left, P_right)\nrenormalize_southwest_corner(quadrant::AbstractTensorMap{S,3,3}, P_left, P_right) where {S}\nrenormalize_southwest_corner(E_south, C_southwest, E_west, P_left, P_right, ket::PEPSTensor, bra::PEPSTensor=ket)\n\nApply renormalize_corner to the enlarged southwest corner. Alternatively, provide the constituent tensors and perform the complete contraction.\n\n               |\n      [~~~~~P_right~~~~~]\n        ||            |\n       E_west   == ket-bra == |~~~~~~|\n         |           ||       |P_left| --\n    C_southwest -- E_south -- |~~~~~~|\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_top_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.renormalize_top_corner","text":"renormalize_top_corner((row, col), envs::CTMRGEnv, projectors)\n\nApply top projector to northwest corner and north edge.\n\n     C -- E -- \n     |    ||\n    [~P_top~]\n        | \n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_west_edge-Union{Tuple{Pb}, Tuple{Pt}, Tuple{Any, CTMRGEnv, Array{Pb, 3}, Array{Pt, 3}, InfinitePEPS}, Tuple{Any, CTMRGEnv, Array{Pb, 3}, Array{Pt, 3}, InfinitePEPS, InfinitePEPS}} where {Pt, Pb}","page":"Library","title":"PEPSKit.renormalize_west_edge","text":"renormalize_west_edge((row, col), envs, P_top, P_bottom, ket, bra)\nrenormalize_west_edge(E_west, P_top, P_bottom, ket, bra)\n\nAbsorb a bra-ket pair into the west edge using the given projectors and environment tensors.\n\n            |\n     [~~P_bottom~~]\n      |         ||\n    E_west == ket-bra\n      |         ||\n     [~~~~P_top~~~]\n            |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.right_projector","page":"Library","title":"PEPSKit.right_projector","text":"right_projector(E_1, C, E_2, U, isqS, ket::PEPSTensor, bra::PEPSTensor=ket)\n\nContract the CTMRG right projector with the higher-dimensional subspace facing to the right.\n\n               |~~| --   E_2   --  C\n    -- isqS -- |U'|      ||        |\n               |~~| == ket-bra == E_1\n                         ||        |\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.rotate_north-Tuple{Any, Any}","page":"Library","title":"PEPSKit.rotate_north","text":"rotate_north(t, dir)\n\nRotate north direction of t to dir by successive applications of rotl90.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.sdiag_pow-Tuple{TensorKit.AbstractTensorMap, Real}","page":"Library","title":"PEPSKit.sdiag_pow","text":"sdiag_pow(S::AbstractTensorMap, pow::Real; tol::Real=eps(scalartype(S))^(3 / 4))\n\nCompute S^pow for diagonal matrices S.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.sequential_projectors-Tuple{Int64, InfinitePEPS, CTMRGEnv, PEPSKit.ProjectorAlgorithm}","page":"Library","title":"PEPSKit.sequential_projectors","text":"sequential_projectors(col::Int, state::InfinitePEPS, envs::CTMRGEnv, alg::ProjectorAlgorithm)\nsequential_projectors(coordinate::NTuple{3,Int}, state::InfinitePEPS, envs::CTMRGEnv, alg::ProjectorAlgorithm)\n\nCompute CTMRG projectors in the :sequential scheme either for an entire column col or for a specific coordinate (where dir=WEST is already implied in the :sequential scheme).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.simpleupdate-Tuple{InfiniteWeightPEPS, LocalOperator, SimpleUpdate}","page":"Library","title":"PEPSKit.simpleupdate","text":"simpleupdate(peps::InfiniteWeightPEPS, ham::LocalOperator, alg::SimpleUpdate;\n             bipartite::Bool=false, check_int::Int=500)\n\nPerform simple update with nearest neighbor Hamiltonian ham, where the evolution information is printed every check_int steps. \n\nIf bipartite == true (for square lattice), a unit cell size of (2, 2) is assumed,  as well as tensors and x/y weights which are the same across the diagonals, i.e. at (row, col) and (row+1, col+1).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.simultaneous_projectors-Union{Tuple{E}, Tuple{Array{E, 3}, CTMRGEnv, PEPSKit.ProjectorAlgorithm}} where E","page":"Library","title":"PEPSKit.simultaneous_projectors","text":"simultaneous_projectors(enlarged_corners::Array{E,3}, envs::CTMRGEnv, alg::ProjectorAlgorithm)\nsimultaneous_projectors(coordinate, enlarged_corners::Array{E,3}, alg::ProjectorAlgorithm)\n\nCompute CTMRG projectors in the :simultaneous scheme either for all provided enlarged corners or on a specific coordinate.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.su_iter-Tuple{LocalOperator, InfiniteWeightPEPS, SimpleUpdate}","page":"Library","title":"PEPSKit.su_iter","text":"su_iter(gate::LocalOperator, peps::InfiniteWeightPEPS, alg::SimpleUpdate; bipartite::Bool=false)\n\nOne round of simple update on peps applying the nearest neighbor gate.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.symmetrize!-Tuple{InfinitePEPS, Nothing}","page":"Library","title":"PEPSKit.symmetrize!","text":"symmetrize!(peps::InfinitePEPS, ::SymmetrizationStyle)\n\nSymmetrize a PEPS using the given SymmetrizationStyle in-place.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.symmetrize_retract_and_finalize!-Tuple{PEPSKit.SymmetrizationStyle}","page":"Library","title":"PEPSKit.symmetrize_retract_and_finalize!","text":"symmetrize_retract_and_finalize!(symm::SymmetrizationStyle)\n\nReturn the retract and finalize! function for symmetrizing the peps and grad tensors.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TensorKit.tsvd-Tuple{Any, Any}","page":"Library","title":"TensorKit.tsvd","text":"PEPSKit.tsvd(t, alg; trunc=notrunc(), p=2)\n\nWrapper around TensorKit.tsvd which dispatches on the alg argument. This is needed since a custom adjoint for PEPSKit.tsvd may be defined, depending on the algorithm. E.g., for IterSVD the adjoint for a truncated SVD from KrylovKit.svdsolve is used.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.@autoopt-Tuple{Any}","page":"Library","title":"PEPSKit.@autoopt","text":"autoopt(ex)\n\nPreprocessor macro for @tensor which automatically inserts costs for all symbols that start with a pattern. In particular, all labels that start with d, D, or χ are automatically inserted with the corresponding costs.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.@diffset-Tuple{Any}","page":"Library","title":"PEPSKit.@diffset","text":"@diffset assign\n\nHelper macro which allows in-place operations in the forward-pass of Zygote, but resorts to non-mutating operations in the backwards-pass. The expression assign should assign an object to an pre-existing AbstractArray and the use of updating operators is also possible. This is especially needed when in-place assigning tensors to unit-cell arrays of environments.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.@fwdthreads-Tuple{Any}","page":"Library","title":"PEPSKit.@fwdthreads","text":"@fwdthreads(ex)\n\nApply Threads.@threads only in the forward pass of the program.\n\nIt works by wrapping the for-loop expression in an if statement where in the forward pass the loop in computed in parallel using Threads.@threads, whereas in the backwards pass the Threads.@threads is omitted in order to make the expression differentiable.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.@showtypeofgrad-Tuple{Any}","page":"Library","title":"PEPSKit.@showtypeofgrad","text":"@showtypeofgrad(x)\n\nMacro utility to show to type of the gradient that is about to accumulate for x.\n\nSee also Zygote.@showgrad.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.Defaults","page":"Library","title":"PEPSKit.Defaults","text":"module Defaults\n    const ctmrg_maxiter = 100\n    const ctmrg_miniter = 4\n    const ctmrg_tol = 1e-8\n    const fpgrad_maxiter = 30\n    const fpgrad_tol = 1e-6\n    const reuse_env = true\n    const trscheme = FixedSpaceTruncation()\n    const fwd_alg = TensorKit.SDD()\n    const rrule_alg = Arnoldi(; tol=1e-2fpgrad_tol, krylovdim=48, verbosity=-1)\n    const svd_alg = SVDAdjoint(; fwd_alg, rrule_alg)\n    const projector_alg_type = HalfInfiniteProjector\n    const projector_alg = projector_alg_type(svd_alg, trscheme, 2)\n    const ctmrg_alg = SimultaneousCTMRG(\n        ctmrg_tol, ctmrg_maxiter, ctmrg_miniter, 2, projector_alg\n    )\n    const optimizer = LBFGS(32; maxiter=100, gradtol=1e-4, verbosity=2)\n    const gradient_linsolver = KrylovKit.BiCGStab(;\n        maxiter=Defaults.fpgrad_maxiter, tol=Defaults.fpgrad_tol\n    )\n    const iterscheme = :fixed\n    const gradient_alg = LinSolver(; solver=gradient_linsolver, iterscheme)\n    const scheduler = Ref{Scheduler}(Threads.nthreads() == 1 ? SerialScheduler() : DynamicScheduler())\nend\n\nModule containing default values that represent typical algorithm parameters.\n\nctmrg_maxiter: Maximal number of CTMRG iterations per run\nctmrg_miniter: Minimal number of CTMRG carried out\nctmrg_tol: Tolerance checking singular value and norm convergence\nfpgrad_maxiter: Maximal number of iterations for computing the CTMRG fixed-point gradient\nfpgrad_tol: Convergence tolerance for the fixed-point gradient iteration\nreuse_env: If true, the current optimization step is initialized on the previous environment\ntrscheme: Truncation scheme for SVDs and other decompositions\nfwd_alg: SVD algorithm that is used in the forward pass\nrrule_alg: Reverse-rule for differentiating that SVD\nsvd_alg: Combination of fwd_alg and rrule_alg\nprojector_alg_type: Default type of projector algorithm\nprojector_alg: Algorithm to compute CTMRG projectors\nctmrg_alg: Algorithm for performing CTMRG runs\noptimizer: Optimization algorithm for PEPS ground-state optimization\ngradient_linsolver: Default linear solver for the LinSolver gradient algorithm\niterscheme: Scheme for differentiating one CTMRG iteration\ngradient_alg: Algorithm to compute the gradient fixed-point\nscheduler: Multi-threading scheduler which can be accessed via set_scheduler!\n\n\n\n\n\n","category":"module"},{"location":"lib/lib/#PEPSKit.Defaults.set_scheduler!","page":"Library","title":"PEPSKit.Defaults.set_scheduler!","text":"set_scheduler!([scheduler]; kwargs...)\n\nSet OhMyThreads multi-threading scheduler parameters.\n\nThe function either accepts a scheduler as an OhMyThreads.Scheduler or as a symbol where the corresponding parameters are specificed as keyword arguments. For instance, a static scheduler that uses four tasks with chunking enabled can be set via\n\nset_scheduler!(StaticScheduler(; ntasks=4, chunking=true))\n\nor equivalently with \n\nset_scheduler!(:static; ntasks=4, chunking=true)\n\nFor a detailed description of all schedulers and their keyword arguments consult the OhMyThreads documentation.\n\nIf no scheduler is passed and only kwargs are provided, the DynamicScheduler constructor is used with the provided kwargs.\n\nTo reset the scheduler to its default value, one calls set_scheduler! without passing arguments which then uses the default DynamicScheduler(). If the number of used threads is just one it falls back to SerialScheduler().\n\n\n\n\n\n","category":"function"},{"location":"man/intro/","page":"Manual","title":"Manual","text":"Coming soon.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For now, refer to the examples folder on GitHub.","category":"page"},{"location":"#PEPSKit.jl","page":"Home","title":"PEPSKit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools for working with projected entangled-pair states","category":"page"},{"location":"","page":"Home","title":"Home","text":"It contracts, it optimizes, it may break.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed through the Julia general registry, via the package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add PEPSKit","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After following the installation process, it should now be possible to load the packages and start simulating. For example, in order to obtain the groundstate of the 2D Heisenberg model, we can use the following code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TensorKit, PEPSKit, KrylovKit, OptimKit\n\n# constructing the Hamiltonian:\nH = heisenberg_XYZ(InfiniteSquare(); Jx=-1, Jy=1, Jz=-1) # sublattice rotation to obtain single-site unit cell\n\n# configuring the parameters\nD = 2\nchi = 20\nctm_alg = SimultaneousCTMRG(; tol=1e-10, trscheme=truncdim(chi))\nopt_alg = PEPSOptimize(;\n    boundary_alg=ctm_alg,\n    optimizer=LBFGS(4; maxiter=100, gradtol=1e-4, verbosity=2),\n    gradient_alg=LinSolver(),\n    reuse_env=true,\n)\n\n# ground state search\nstate = InfinitePEPS(2, D)\nctm = leading_boundary(CTMRGEnv(state, ComplexSpace(chi)), state, ctm_alg)\nresult = fixedpoint(state, H, opt_alg, ctm)\n\n@show result.E # -0.6625...","category":"page"}]
}
