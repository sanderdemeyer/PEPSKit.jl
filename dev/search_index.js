var documenterSearchIndex = {"docs":
[{"location":"lib/lib/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/lib/","page":"Library","title":"Library","text":"Modules = [PEPSKit, PEPSKit.Defaults]\nFilter = t -> !(t in [PEPSKit.PEPS_∂∂AC, PEPSKit.PEPS_∂∂C, PEPSKit.PEPO_∂∂AC, PEPSKit.PEPO_∂∂C])","category":"page"},{"location":"lib/lib/#PEPSKit.AbstractPEPO","page":"Library","title":"PEPSKit.AbstractPEPO","text":"abstract type AbstractPEPO end\n\nAbstract supertype for a 2D projected entangled-pair operator.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.AbstractPEPS","page":"Library","title":"PEPSKit.AbstractPEPS","text":"abstract type AbstractPEPS end\n\nAbstract supertype for a 2D projected entangled-pair state.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRG","page":"Library","title":"PEPSKit.CTMRG","text":"CTMRG(; tol=Defaults.ctmrg_tol, maxiter=Defaults.ctmrg_maxiter,\n      miniter=Defaults.ctmrg_miniter, verbosity=0,\n      svd_alg=SVDAdjoint(), trscheme=FixedSpaceTruncation(),\n      ctmrgscheme=Defaults.ctmrgscheme)\n\nAlgorithm struct that represents the CTMRG algorithm for contracting infinite PEPS. Each CTMRG run is converged up to tol where the singular value convergence of the corners as well as the norm is checked. The maximal and minimal number of CTMRG iterations is set with maxiter and miniter. Different levels of output information are printed depending on verbosity, where 0 suppresses all output, 1 only prints warnings, 2 gives information at the start and end, and 3 prints information every iteration.\n\nThe projectors are computed from svd_alg SVDs where the truncation scheme is set via  trscheme.\n\nIn general, two different schemes can be selected with ctmrgscheme which determine how CTMRG is implemented. It can either be :sequential, where the projectors are succesively computed on the western side, and then applied and rotated. Or with :simultaneous all projectors are computed and applied simultaneously on all sides, where in particular the corners get contracted with two projectors at the same time.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGEnv","page":"Library","title":"PEPSKit.CTMRGEnv","text":"struct CTMRGEnv{C,T}\n\nCorner transfer-matrix environment containing unit-cell arrays of corner and edge tensors. The last two indices of the arrays correspond to the row and column indices of the unit cell, whereas the first index corresponds to the direction of the corner or edge tensor. The directions are labeled in clockwise direction, starting from the north-west corner and north edge respectively.\n\nGiven arrays of corners c and edges t, they connect to the PEPS tensors at site (r, c) in the unit cell as:\n\n   c[1,r-1,c-1]---t[1,r-1,c]----c[2,r-1,c+1]\n   |              ||            |\n   t[4,r,c-1]=====AA[r,c]=======t[2,r,c+1]\n   |              ||            |\n   c[4,r+1,c-1]---t[3,r+1,c]----c[3,r+1,c+1]\n\nFields\n\ncorners::Array{C,3}: Array of corner tensors.\nedges::Array{T,3}: Array of edge tensors.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{A}, Tuple{A, A, A}, NTuple{4, A}, NTuple{5, A}, NTuple{6, A}} where A<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, ComplexF64], Ds_north, Ds_east::A, chis_north::A, [chis_east::A], [chis_south::A], [chis_west::A]\n) where {A<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\n\nConstruct a CTMRG environment by specifying matrices of north and east virtual spaces of the corresponding InfinitePEPS and the north, east, south and west virtual spaces of the environment. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual environment spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site (r, c), chis_north[r, c] corresponds to the east space of the north edge tensor, chis_east[r, c] corresponds to the north space of the east edge tensor, chis_south[r, c] corresponds to the east space of the south edge tensor, and chis_west[r, c] corresponds to the north space of the west edge tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{A}, Tuple{InfinitePEPS, A}, Tuple{InfinitePEPS, A, A}, Tuple{InfinitePEPS, A, A, A}, Tuple{InfinitePEPS, Vararg{A, 4}}} where A<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, T=ComplexF64], peps::InfinitePEPS, chis_north::A, [chis_east::A], [chis_south::A], [chis_west::A]\n) where {A<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\n\nConstruct a CTMRG environment by specifying a corresponding InfinitePEPS, and the north, east, south and west virtual spaces of the environment as matrices. Each respective matrix entry corresponds to a site in the unit cell. By default, the virtual spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to the north or east virtual space of the corresponding edge tensor for each direction. Specifically, for a given site (r, c), chis_north[r, c] corresponds to the east space of the north edge tensor, chis_east[r, c] corresponds to the north space of the east edge tensor, chis_south[r, c] corresponds to the east space of the south edge tensor, and chis_west[r, c] corresponds to the north space of the west edge tensor.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{InfinitePEPS, S}, Tuple{InfinitePEPS, S, S}, Tuple{InfinitePEPS, S, S, S}, Tuple{InfinitePEPS, Vararg{S, 4}}} where S<:Union{Int64, TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    peps::InfinitePEPS, chi_north::S, [chi_east::S], [chi_south::S], [chi_west::S],\n) where {S<:Union{Int,ElementarySpace}}\n\nConstruct a CTMRG environment by specifying a corresponding InfinitePEPS, and the north, east, south and west virtual spaces of the environment. By default, the virtual spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to virtual space of the corresponding edge tensor for each direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.CTMRGEnv-Union{Tuple{S}, Tuple{S, S, S}, NTuple{4, S}, NTuple{5, S}, NTuple{6, S}} where S<:Union{Int64, TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.CTMRGEnv","text":"CTMRGEnv(\n    [f=randn, ComplexF64], D_north::S, D_south::S, chi_north::S, [chi_east::S], [chi_south::S], [chi_west::S]; unitcell::Tuple{Int,Int}=(1, 1),\n) where {S<:Union{Int,ElementarySpace}}\n\nConstruct a CTMRG environment by specifying the north and east virtual spaces of the corresponding InfinitePEPS and the north, east, south and west virtual spaces of the environment. The PEPS unit cell can be specified by the unitcell keyword argument. By default, the virtual environment spaces for all directions are taken to be the same.\n\nThe environment virtual spaces for each site correspond to virtual space of the corresponding edge tensor for each direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.FixedSVD","page":"Library","title":"PEPSKit.FixedSVD","text":"struct FixedSVD\n\nSVD struct containing a pre-computed decomposition or even multiple ones. The call to tsvd just returns the pre-computed U, S and V. In the reverse pass, the SVD adjoint is computed with these exact U, S, and V.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.FixedSpaceTruncation","page":"Library","title":"PEPSKit.FixedSpaceTruncation","text":"FixedSpaceTruncation <: TensorKit.TruncationScheme\n\nCTMRG specific truncation scheme for tsvd which keeps the bond space on which the SVD is performed fixed. Since different environment directions and unit cell entries might have different spaces, this truncation style is different from TruncationSpace.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.GeomSum","page":"Library","title":"PEPSKit.GeomSum","text":"struct GeomSum(; maxiter=Defaults.fpgrad_maxiter, tol=Defaults.fpgrad_tol,\n               verbosity=0, iterscheme=Defaults.iterscheme) <: GradMode{iterscheme}\n\nGradient mode for CTMRG using explicit evaluation of the geometric sum.\n\nWith iterscheme the style of CTMRG iteration which is being differentiated can be chosen. If set to :fixed, the differentiated CTMRG iteration is assumed to have a pre-computed SVD of the environments with a fixed set of gauges. Alternatively, if set to :diffgauge, the differentiated iteration consists of a CTMRG iteration and a subsequent gauge fixing step, such that gauge_fix will also be differentiated everytime a CTMRG derivative is computed.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPO","page":"Library","title":"PEPSKit.InfinitePEPO","text":"struct InfinitePEPO{T<:PEPOTensor}\n\nRepresents an infinite projected entangled-pair operator (PEPO) on a 3D cubic lattice.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Tuple{T} where T<:(TensorKit.AbstractTensorMap{S, 2, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(A; unitcell=(1, 1, 1))\n\nCreate an InfinitePEPO by specifying a tensor and unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T<:(TensorKit.AbstractTensorMap{S, 2, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(A::AbstractArray{T, 3})\n\nAllow users to pass in an array of tensors.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{A}, Tuple{A, A}, Tuple{A, A, A}} where A<:(AbstractArray{<:TensorKit.ElementarySpace, 3})","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(f=randn, T=ComplexF64, Pspaces, Nspaces, Espaces)\n\nAllow users to pass in arrays of spaces.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPO-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S<:TensorKit.ElementarySpace","page":"Library","title":"PEPSKit.InfinitePEPO","text":"InfinitePEPO(f=randn, T=ComplexF64, Pspace, Nspace, [Espace]; unitcell=(1,1,1))\n\nCreate an InfinitePEPO by specifying its spaces and unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS","page":"Library","title":"PEPSKit.InfinitePEPS","text":"struct InfinitePEPS{T<:PEPSTensor}\n\nRepresents an infinite projected entangled-pair state on a 2D square lattice.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Tuple{T} where T<:(TensorKit.AbstractTensorMap{S, 1, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(A; unitcell=(1, 1))\n\nCreate an InfinitePEPS by specifying a tensor and unit cell.\n\nThe unit cell is labeled as a matrix which means that any tensor in the unit cell, regardless if PEPS tensor or environment tensor, is obtained by shifting the row and column index [r, c] by one, respectively:\n\n   |            |          |\n---C[r-1,c-1]---T[r-1,c]---T[r-1,c+1]---\n   |            ||         ||\n---T[r,c-1]=====AA[r,c]====AA[r,c+1]====\n   |            ||         ||\n---T[r+1,c-1]===AA[r+1,c]==AA[r+1,c+1]==\n   |            ||         ||\n\nThe unit cell has periodic boundary conditions, so [r, c] is indexed modulo the size of the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:(TensorKit.AbstractTensorMap{S, 1, 4} where S<:TensorKit.ElementarySpace)","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(A::AbstractMatrix{T})\n\nCreate an InfinitePEPS by specifying a matrix containing the PEPS tensors at each site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Union{Tuple{A}, Tuple{A, A, A}} where A<:(AbstractMatrix{<:Union{Int64, TensorKit.ElementarySpace}})","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(\n    f=randn, T=ComplexF64, Pspaces::A, Nspaces::A, [Espaces::A]\n) where {A<:AbstractMatrix{<:Union{Int,ElementarySpace}}}\n\nCreate an InfinitePEPS by specifying the physical, north virtual and east virtual spaces of the PEPS tensor at each site in the unit cell as a matrix. Each individual space can be specified as either an Int or an ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfinitePEPS-Union{Tuple{S}, Tuple{S, S}, Tuple{S, S, S}} where S<:Union{Int64, TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.InfinitePEPS","text":"InfinitePEPS(f=randn, T=ComplexF64, Pspace, Nspace, [Espace]; unitcell=(1,1))\n\nCreate an InfinitePEPS by specifying its physical, north and east spaces and unit cell. Spaces can be specified either via Int or via ElementarySpace.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPO","page":"Library","title":"PEPSKit.InfiniteTransferPEPO","text":"InfiniteTransferPEPO{T,O}\n\nRepresents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the expectation value of an InfinitePEPO between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPO-Tuple{InfinitePEPS, InfinitePEPO, Any, Any}","page":"Library","title":"PEPSKit.InfiniteTransferPEPO","text":"InfiniteTransferPEPO(T::InfinitePEPS, O::InfinitePEPO, dir, row)\n\nConstructs a transfer operator corresponding to a single row of a partition function representing the expectation value of O for the state T. The partition function is first rotated such that the direction dir faces north, after which its rowth row from the north is selected.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPS","page":"Library","title":"PEPSKit.InfiniteTransferPEPS","text":"InfiniteTransferPEPS{T}\n\nRepresents an infinite transfer operator corresponding to a single row of a partition function which corresponds to the overlap between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.InfiniteTransferPEPS-Tuple{InfinitePEPS, Any, Any}","page":"Library","title":"PEPSKit.InfiniteTransferPEPS","text":"InfiniteTransferPEPS(T::InfinitePEPS, dir, row)\n\nConstructs a transfer operator corresponding to a single row of a partition function representing the norm of the state T. The partition function is first rotated such that the direction dir faces north, after which its rowth row from the north is selected.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.IterSVD","page":"Library","title":"PEPSKit.IterSVD","text":"struct IterSVD(; alg=KrylovKit.GKL(), fallback_threshold = Inf)\n\nIterative SVD solver based on KrylovKit's GKL algorithm, adapted to (symmetric) tensors. The number of targeted singular values is set via the TruncationSpace in ProjectorAlg. In particular, this make it possible to specify the targeted singular values block-wise. In case the symmetry block is too small as compared to the number of singular values, or the iterative SVD didn't converge, the algorithm falls back to a dense SVD.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.LinSolver","page":"Library","title":"PEPSKit.LinSolver","text":"struct LinSolver(; solver=KrylovKit.GMRES(), iterscheme=Defaults.iterscheme) <: GradMode{iterscheme}\n\nGradient mode wrapper around KrylovKit.LinearSolver for solving the gradient linear problem using iterative solvers.\n\nWith iterscheme the style of CTMRG iteration which is being differentiated can be chosen. If set to :fixed, the differentiated CTMRG iteration is assumed to have a pre-computed SVD of the environments with a fixed set of gauges. Alternatively, if set to :diffgauge, the differentiated iteration consists of a CTMRG iteration and a subsequent gauge fixing step, such that gauge_fix will also be differentiated everytime a CTMRG derivative is computed.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.LocalOperator","page":"Library","title":"PEPSKit.LocalOperator","text":"struct LocalOperator{T<:Tuple,S}\n\nA sum of local operators acting on a lattice. The lattice is stored as a matrix of vector spaces, and the terms are stored as a tuple of pairs of indices and operators.\n\nFields\n\nlattice::Matrix{S}: The lattice on which the operator acts.\nterms::T: The terms of the operator, stored as a tuple of pairs of indices and operators.\n\nConstructors\n\nLocalOperator(lattice::Matrix{S}, terms::Pair...)\nLocalOperator{T,S}(lattice::Matrix{S}, terms::T) where {T,S} # expert mode\n\nExamples\n\nlattice = fill(ℂ^2, 1, 1) # single-site unitcell\nO1 = LocalOperator(lattice, ((1, 1),) => σx, ((1, 1), (1, 2)) => σx ⊗ σx, ((1, 1), (2, 1)) => σx ⊗ σx)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ManualIter","page":"Library","title":"PEPSKit.ManualIter","text":"struct ManualIter(; maxiter=Defaults.fpgrad_maxiter, tol=Defaults.fpgrad_tol,\n                  verbosity=0, iterscheme=Defaults.iterscheme) <: GradMode{iterscheme}\n\nGradient mode for CTMRG using manual iteration to solve the linear problem.\n\nWith iterscheme the style of CTMRG iteration which is being differentiated can be chosen. If set to :fixed, the differentiated CTMRG iteration is assumed to have a pre-computed SVD of the environments with a fixed set of gauges. Alternatively, if set to :diffgauge, the differentiated iteration consists of a CTMRG iteration and a subsequent gauge fixing step, such that gauge_fix will also be differentiated everytime a CTMRG derivative is computed.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.NonTruncSVDAdjoint","page":"Library","title":"PEPSKit.NonTruncSVDAdjoint","text":"struct NonTruncAdjoint\n\nOld SVD adjoint that does not account for the truncated part of truncated SVDs.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPOTensor","page":"Library","title":"PEPSKit.PEPOTensor","text":"const PEPOTensor{S}\n\nDefault type for PEPO tensors with a single incoming and outgoing physical index, and 4 virtual indices, conventionally ordered as: O : P ⊗ P' ← N ⊗ E ⊗ S ⊗ W.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSOptimize","page":"Library","title":"PEPSKit.PEPSOptimize","text":"PEPSOptimize{G}(; boundary_alg=CTMRG(), optimizer::OptimKit.OptimizationAlgorithm=Defaults.optimizer\n                reuse_env::Bool=true, gradient_alg::G=LinSolver())\n\nAlgorithm struct that represent PEPS ground-state optimization using AD. Set the algorithm to contract the infinite PEPS in boundary_alg; currently only CTMRG is supported. The optimizer computes the gradient directions based on the CTMRG gradient and updates the PEPS parameters. In this optimization, the CTMRG runs can be started on the converged environments of the previous optimizer step by setting reuse_env to true. Otherwise a random environment is used at each step. The CTMRG gradient itself is computed using the gradient_alg algorithm.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSTensor","page":"Library","title":"PEPSKit.PEPSTensor","text":"const PEPSTensor{S}\n\nDefault type for PEPS tensors with a single physical index, and 4 virtual indices, conventionally ordered as: T  P  N  E  S  W. Here, P, N, E, S and W denote the physics, north, east, south and west spaces, respectively.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.PEPSTensor-Union{Tuple{S}, Tuple{T}, Tuple{Any, Type{T}, S, S}, Tuple{Any, Type{T}, S, S, S}, Tuple{Any, Type{T}, Vararg{S, 4}}, Tuple{Any, Type{T}, Vararg{S, 5}}} where {T, S<:TensorKit.ElementarySpace}","page":"Library","title":"PEPSKit.PEPSTensor","text":"PEPSTensor(f, ::Type{T}, Pspace::S, Nspace::S,\n           [Espace::S], [Sspace::S], [Wspace::S]) where {T,S<:ElementarySpace}\nPEPSTensor(f, ::Type{T}, Pspace::Int, Nspace::Int,\n           [Espace::Int], [Sspace::Int], [Wspace::Int]) where {T}\n\nConstruct a PEPS tensor based on the physical, north, east, west and south spaces. Alternatively, only the space dimensions can be provided and ℂ is assumed as the field. The tensor elements are generated based on f and the element type is specified in T.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ProjectorAlg","page":"Library","title":"PEPSKit.ProjectorAlg","text":"struct ProjectorAlg{S}(; svd_alg=TensorKit.SVD(), trscheme=TensorKit.notrunc(),\n                       fixedspace=false, verbosity=0)\n\nAlgorithm struct collecting all projector related parameters. The truncation scheme has to be a TensorKit.TruncationScheme, and some SVD algorithms might have further restrictions on what kind of truncation scheme can be used. If fixedspace is true, the truncation scheme is set to truncspace(V) where V is the environment bond space, adjusted to the corresponding environment direction/unit cell entry.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ReflectDepth","page":"Library","title":"PEPSKit.ReflectDepth","text":"struct ReflectDepth <: SymmetrizationStyle\n\nReflection symmmetrization along the horizontal axis, such that north and south are mirrored.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.ReflectWidth","page":"Library","title":"PEPSKit.ReflectWidth","text":"struct ReflectWidth <: SymmetrizationStyle\n\nReflection symmmetrization along the vertical axis, such that east and west are mirrored.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.RotateReflect","page":"Library","title":"PEPSKit.RotateReflect","text":"struct RotateReflect <: SymmetrizationStyle\n\nFull reflection and rotation symmmetrization, such that reflection along the horizontal and vertical axis as well as π/2 rotations leave the object invariant.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.SVDAdjoint","page":"Library","title":"PEPSKit.SVDAdjoint","text":"struct SVDAdjoint(; fwd_alg=Defaults.fwd_alg, rrule_alg=Defaults.rrule_alg,\n                  broadening=nothing)\n\nWrapper for a SVD algorithm fwd_alg with a defined reverse rule rrule_alg. If isnothing(rrule_alg), Zygote differentiates the forward call automatically. In case of degenerate singular values, one might need a broadening scheme which removes the divergences from the adjoint.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.TransferPEPOMultiline","page":"Library","title":"PEPSKit.TransferPEPOMultiline","text":"const TransferPEPOMultiline = MPSKit.Multiline{<:InfiniteTransferPEPO}\n\nType that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap of an InfinitePEPO between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.TransferPEPOMultiline-Tuple{InfinitePEPS, InfinitePEPO, Any}","page":"Library","title":"PEPSKit.TransferPEPOMultiline","text":"TransferPEPOMultiline(T::InfinitePEPS, O::InfinitePEPO, dir)\n\nConstruct a multi-row transfer operator corresponding to the partition function representing the expectation value of O for the state T. The partition function is first rotated such that the direction dir faces north.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.TransferPEPSMultiline","page":"Library","title":"PEPSKit.TransferPEPSMultiline","text":"const TransferPEPSMultiline = MPSKit.Multiline{<:InfiniteTransferPEPS}\n\nType that represents a multi-line transfer operator, where each line each corresponds to a row of a partition function encoding the overlap between 'ket' and 'bra' InfinitePEPS states.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#PEPSKit.TransferPEPSMultiline-Tuple{InfinitePEPS, Any}","page":"Library","title":"PEPSKit.TransferPEPSMultiline","text":"TransferPEPSMultiline(T::InfinitePEPS, dir)\n\nConstruct a multi-row transfer operator corresponding to the partition function representing the norm of the state T. The partition function is first rotated such that the direction dir faces north.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.correlation_length-Tuple{InfinitePEPS, CTMRGEnv}","page":"Library","title":"MPSKit.correlation_length","text":"correlation_length(peps::InfinitePEPS, env::CTMRGEnv; howmany=2)\n\nCompute the PEPS correlation length based on the horizontal and vertical transfer matrices. Additionally the (normalized) eigenvalue spectrum is returned. Specify the number of computed eigenvalues with howmany.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.expectation_value-Tuple{Any, Any}","page":"Library","title":"MPSKit.expectation_value","text":"MPSKit.expectation_value(st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO})\nMPSKit.expectation_value(st::MPSMultiline, op::Union{TransferPEPSMultiline,TransferPEPOMultiline})\n\nCompute expectation value of the transfer operator op for the state st for each site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.leading_boundary-Tuple{Any, Any, Any}","page":"Library","title":"MPSKit.leading_boundary","text":"MPSKit.leading_boundary(\n    st::InfiniteMPS, op::Union{InfiniteTransferPEPS,InfiniteTransferPEPO}, alg, [envs]\n)\nMPSKit.leading_boundary(\n    st::MPSMulitline, op::Union{TransferPEPSMultiline,TransferPEPOMultiline}, alg, [envs]\n)\n\nApproximate the leading boundary MPS eigenvector for the transfer operator op using st as initial guess.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#MPSKit.leading_boundary-Tuple{Any, CTMRG}","page":"Library","title":"MPSKit.leading_boundary","text":"MPSKit.leading_boundary([envinit], state, alg::CTMRG)\n\nContract state using CTMRG and return the CTM environment. Per default, a random initial environment is used.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit._rrule-Tuple{Nothing, ChainRulesCore.RuleConfig, Any, Vararg{Any}}","page":"Library","title":"PEPSKit._rrule","text":"_rrule(alg_rrule, config, f, args...; kwargs...) -> ∂f, ∂args...\n\nCustomize the pullback of a function f. This function can specialize on its first argument in order to have multiple implementations for a pullback. If no specialization is needed, the default alg_rrule=nothing results in the default AD pullback.\n\nwarning: Warning\nNo tangent is expected for the alg_rrule argument\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.calc_elementwise_convergence-Tuple{CTMRGEnv, CTMRGEnv}","page":"Library","title":"PEPSKit.calc_elementwise_convergence","text":"calc_elementwise_convergence(envfinal, envfix; atol=1e-6)\n\nCheck if the element-wise difference of the corner and edge tensors of the final and fixed CTMRG environments are below some tolerance.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.checklattice-Tuple","page":"Library","title":"PEPSKit.checklattice","text":"checklattice(Bool, args...)\nchecklattice(args...)\n\nHelper function for checking lattice compatibility. The first version returns a boolean, while the second version throws an error if the lattices do not match.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_localnorm-Union{Tuple{N}, Tuple{Tuple{Vararg{CartesianIndex{2}, N}}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where N","page":"Library","title":"PEPSKit.contract_localnorm","text":"contract_localnorm(inds, peps, env)\n\nContract a local norm of the PEPS peps around indices inds.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.contract_localoperator-Union{Tuple{N}, Tuple{S}, Tuple{Tuple{Vararg{CartesianIndex{2}, N}}, TensorKit.AbstractTensorMap{S, N, N}, InfinitePEPS, InfinitePEPS, CTMRGEnv}} where {S, N}","page":"Library","title":"PEPSKit.contract_localoperator","text":"contract_localoperator(inds, O, peps, env)\n\nContract a local operator O on the PEPS peps at the indices inds using the environment env.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ctmrg_expand-Union{Tuple{T}, Tuple{C}, Tuple{Any, CTMRGEnv{C, T}, CTMRG{:sequential}}} where {C, T}","page":"Library","title":"PEPSKit.ctmrg_expand","text":"ctmrg_expand(state, envs, alg::CTMRG{M})\n\nExpand the environment by absorbing a new PEPS tensor. There are two modes of expansion: M = :sequential and M = :simultaneous. The first mode expands the environment in one direction at a time, for convenience towards the left. The second mode expands the environment in all four directions simultaneously.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ctmrg_iter-Tuple{Any, CTMRGEnv, CTMRG{:sequential}}","page":"Library","title":"PEPSKit.ctmrg_iter","text":"ctmrg_iter(state, envs::CTMRGEnv, alg::CTMRG) -> envs′, info\n\nPerform one iteration of CTMRG that maps the state and envs to a new environment, and also returns the truncation error.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ctmrg_projectors-Union{Tuple{E}, Tuple{C}, Tuple{Any, CTMRGEnv{C, E}, CTMRG{:sequential}}} where {C, E}","page":"Library","title":"PEPSKit.ctmrg_projectors","text":"ctmrg_projectors(Q, env, alg::CTMRG{M})\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.ctmrg_renormalize-Tuple{Any, Any, Any, CTMRG{:sequential}}","page":"Library","title":"PEPSKit.ctmrg_renormalize","text":"ctmrg_renormalize(enlarged_envs, projectors, state, envs, alg::CTMRG{M})\n\nApply projectors to renormalize corners and edges.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.enlarge_northeast_corner","page":"Library","title":"PEPSKit.enlarge_northeast_corner","text":"enlarge_northeast_corner((row, col), envs, ket, bra)\nenlarge_northeast_corner(E_north, C_northeast, E_east, ket, bra)\n\nContract the enlarged northeast corner of the CTMRG environment, either by specifying the coordinates, environments and state, or by directly providing the tensors.\n\n    -- E_north -- C_northeast\n          ||            |\n    == ket-bra ==    E_east\n          ||            |\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.enlarge_northwest_corner","page":"Library","title":"PEPSKit.enlarge_northwest_corner","text":"enlarge_northwest_corner((row, col), envs, ket, bra)\nenlarge_northwest_corner(E_west, C_northwest, E_north, ket, bra)\n\nContract the enlarged northwest corner of the CTMRG environment, either by specifying the coordinates, environments and state, or by directly providing the tensors.\n\n    C_northwest -- E_north --\n         |            ||\n      E_west    == ket-bra ==\n         |            ||\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.enlarge_southeast_corner","page":"Library","title":"PEPSKit.enlarge_southeast_corner","text":"enlarge_southeast_corner((row, col), envs, ket, bra)\nenlarge_southeast_corner(E_east, C_southeast, E_south, ket, bra)\n\nContract the enlarged southeast corner of the CTMRG environment, either by specifying the coordinates, environments and state, or by directly providing the tensors.\n\n          ||            |\n    == ket-bra ==    E_east\n          ||            |\n    -- E_south -- C_southeast\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.enlarge_southwest_corner","page":"Library","title":"PEPSKit.enlarge_southwest_corner","text":"enlarge_southwest_corner((row, col), envs, ket, bra)\nenlarge_southwest_corner(E_south, C_southwest, E_west, ket, bra)\n\nContract the enlarged southwest corner of the CTMRG environment, either by specifying the coordinates, environments and state, or by directly providing the tensors.\n\n          |           ||      \n       E_west   == ket-bra == \n          |           ||      \n    C_southwest -- E_south -- \n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.fix_gauge_corner-Tuple{TensorKit.AbstractTensorMap{S, 1, 1} where S, TensorKit.AbstractTensorMap{S, 1, 1} where S, TensorKit.AbstractTensorMap{S, 1, 1} where S}","page":"Library","title":"PEPSKit.fix_gauge_corner","text":"fix_gauge_corner(corner, σ_in, σ_out)\n\nMultiply corner tensor with incoming and outgoing gauge signs.\n\n    corner -- σ_out --\n      |  \n     σ_in\n      |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_east_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_east_edge","text":"fix_gauge_east_edge((row, col), envs, signs)\n\nApply fix_gauge_edge to the east edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_east_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_east_left_vecs","text":"fix_gauge_east_left_vecs((row, col), U, signs)\n\nMultiply east left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_east_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_east_right_vecs","text":"fix_gauge_east_right_vecs((row, col), V, signs)\n\nMultiply east right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_edge-Tuple{TensorKit.AbstractTensorMap{S, 3, 1} where S, TensorKit.AbstractTensorMap{S, 1, 1} where S, TensorKit.AbstractTensorMap{S, 1, 1} where S}","page":"Library","title":"PEPSKit.fix_gauge_edge","text":"fix_gauge_edge(edge, σ_in, σ_out)\n\nMultiply edge tensor with incoming and outgoing gauge signs.\n\n    -- σ_in -- edge -- σ_out --\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_north_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_north_edge","text":"fix_gauge_north_edge((row, col), envs, signs)\n\nApply fix_gauge_edge to the north edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_north_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_north_left_vecs","text":"fix_gauge_north_left_vecs((row, col), U, signs)\n\nMultiply north left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_north_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_north_right_vecs","text":"fix_gauge_north_right_vecs((row, col), V, signs)\n\nMultiply north right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_northeast_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_northeast_corner","text":"fix_gauge_northeast_corner((row, col), envs, signs)\n\nApply fix_gauge_corner to the northeast corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_northwest_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_northwest_corner","text":"fix_gauge_northwest_corner((row, col), envs, signs)\n\nApply fix_gauge_corner to the northwest corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_south_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_south_edge","text":"fix_gauge_south_edge((row, col), envs, signs)\n\nApply fix_gauge_edge to the south edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_south_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_south_left_vecs","text":"fix_gauge_south_left_vecs((row, col), U, signs)\n\nMultiply south left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_south_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_south_right_vecs","text":"fix_gauge_south_right_vecs((row, col), V, signs)\n\nMultiply south right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_southeast_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_southeast_corner","text":"fix_gauge_southeast_corner((row, col), envs, signs)\n\nApply fix_gauge_corner to the southeast corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_southwest_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_southwest_corner","text":"fix_gauge_southwest_corner((row, col), envs, signs)\n\nApply fix_gauge_corner to the southwest corner with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_west_edge-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.fix_gauge_west_edge","text":"fix_gauge_south_edge((row, col), envs, signs)\n\nApply fix_gauge_edge to the west edge with appropriate row and column indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_west_left_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_west_left_vecs","text":"fix_gauge_west_left_vecs((row, col), U, signs)\n\nMultiply west left singular vectors with gauge signs from the right.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fix_gauge_west_right_vecs-Tuple{Any, Any, Any}","page":"Library","title":"PEPSKit.fix_gauge_west_right_vecs","text":"fix_gauge_west((row, col), V, signs)\n\nMultiply west right singular vectors with gauge signs from the left.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fixedpoint-Union{Tuple{T}, Tuple{InfinitePEPS{T}, Any, PEPSOptimize}, Tuple{InfinitePEPS{T}, Any, PEPSOptimize, CTMRGEnv}} where T","page":"Library","title":"PEPSKit.fixedpoint","text":"fixedpoint(ψ₀::InfinitePEPS{T}, H, alg::PEPSOptimize, [env₀::CTMRGEnv];\n           finalize!=OptimKit._finalize!) where {T}\n\nOptimize ψ₀ with respect to the Hamiltonian H according to the parameters supplied in alg. The initial environment env₀ serves as an initial guess for the first CTMRG run. By default, a random initial environment is used.\n\nThe finalize! kwarg can be used to insert a function call after each optimization step by utilizing the finalize! kwarg of OptimKit.optimize. The function maps (peps, envs), f, g = finalize!((peps, envs), f, g, numiter).\n\nThe function returns a NamedTuple which contains the following entries:\n\npeps: final InfinitePEPS\nenv: CTMRGEnv corresponding to the final PEPS\nE: final energy\nE_history: convergence history of the energy function\ngrad: final energy gradient\ngradnorm_history: convergence history of the energy gradient norms\nnumfg: total number of calls to the energy function\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.fpgrad","page":"Library","title":"PEPSKit.fpgrad","text":"fpgrad(∂F∂x, ∂f∂x, ∂f∂A, y0, alg)\n\nCompute the gradient of the cost function for CTMRG by solving the following equation:\n\ndx = ∑ₙ (∂f∂x)ⁿ ∂f∂A dA = (1 - ∂f∂x)⁻¹ ∂f∂A dA\n\nwhere ∂F∂x is the gradient of the cost function with respect to the PEPS tensors, ∂f∂x is the partial gradient of the CTMRG iteration with respect to the environment tensors, ∂f∂A is the partial gradient of the CTMRG iteration with respect to the PEPS tensors, and y0 is the initial guess for the fixed-point iteration. The function returns the gradient dx of the fixed-point iteration.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.gauge_fix-Union{Tuple{T}, Tuple{C}, Tuple{CTMRGEnv{C, T}, CTMRGEnv{C, T}}} where {C, T}","page":"Library","title":"PEPSKit.gauge_fix","text":"gauge_fix(envprev::CTMRGEnv{C,T}, envfinal::CTMRGEnv{C,T}) where {C,T}\n\nFix the gauge of envfinal based on the previous environment envprev. This assumes that the envfinal is the result of one CTMRG iteration on envprev. Given that the CTMRG run is converged, the returned environment will be element-wise converged to envprev.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.halfinfinite_environment-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{S, 3, 3}, TensorKit.AbstractTensorMap{S, 3, 3}}} where S","page":"Library","title":"PEPSKit.halfinfinite_environment","text":"halfinfinite_environment(quadrant1::AbstractTensorMap{S,3,3}, quadrant2::AbstractTensorMap{S,3,3})\n\nContract two quadrants (enlarged corners) to form a half-infinite environment.\n\n    |~~~~~~~~~| -- |~~~~~~~~~|\n    |quadrant1|    |quadrant2|\n    |~~~~~~~~~| == |~~~~~~~~~|\n      |    ||        ||    |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.hook_pullback-Tuple{Any, Vararg{Any}}","page":"Library","title":"PEPSKit.hook_pullback","text":"hook_pullback(f, args...; alg_rrule=nothing, kwargs...)\n\nWrapper function to customize the pullback of a function f. This function is equivalent to f(args...; kwargs...), but the pullback can be customized by implementing the following function:\n\n_rrule(alg_rrule, config, f, args...; kwargs...) -> NoTangent(), ∂f, ∂args...\n\nThis function can specialize on its first argument in order to customize the pullback. If no specialization is needed, the default alg_rrule=nothing results in the default AD pullback.\n\nSee also _rrule.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.initializeMPS-Union{Tuple{S}, Tuple{InfiniteTransferPEPS, AbstractVector{S}}} where S","page":"Library","title":"PEPSKit.initializeMPS","text":"initializeMPS(\n    O::Union{InfiniteTransferPEPS,InfiniteTransferPEPO},\n    virtualspaces::AbstractArray{<:ElementarySpace,1}\n)\ninitializeMPS(\n    O::Union{TransferPEPSMultiline,TransferPEPOMultiline},\n    virtualspaces::AbstractArray{<:ElementarySpace,2}\n)\n\nInialize a boundary MPS for the transfer operator O by specifying an array of virtual spaces consistent with the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.projector_type-Tuple{DataType, Any}","page":"Library","title":"PEPSKit.projector_type","text":"projector_type(T::DataType, size)\nprojector_type(edges::Array{<:AbstractTensorMap})\n\nCreate two arrays of specified size that contain undefined tensors representing left and right acting projectors, respectively. The projector types are inferred from the TensorMap type T which avoids having to recompute transpose tensors. Alternatively, supply an array of edge tensors from which left and right projectors are intialized explicitly with zeros.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_bottom_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.renormalize_bottom_corner","text":"renormalize_bottom_corner((r, c), envs, projectors)\n\nApply bottom projector to southwest corner and south edge.\n\n        | \n    [P_bottom]\n     |     ||\n     C --  E -- in\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_corner-Union{Tuple{S}, Tuple{TensorKit.AbstractTensorMap{S, 3, 3}, Any, Any}} where S","page":"Library","title":"PEPSKit.renormalize_corner","text":"renormalize_corner(quadrant, P_left, P_right)\n\nApply projectors to each side of a quadrant.\n\n    |~~~~~~~~| -- |~~~~~~|\n    |quadrant|    |P_left| --\n    |~~~~~~~~| == |~~~~~~|\n     |    ||\n    [P_right]\n        |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_east_edge","page":"Library","title":"PEPSKit.renormalize_east_edge","text":"renormalize_east_edge((row, col), envs, P_top, P_bottom, ket, bra)\nrenormalize_east_edge(E_east, P_top, P_bottom, ket, bra)\n\nAbsorb a bra-ket pair into the east edge using the given projectors and environment tensors.\n\n            |\n     [~~P_bottom~~]\n      |         ||\n    E_east == ket-bra\n      |         ||\n     [~~~~P_top~~~]\n            |\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.renormalize_north_edge","page":"Library","title":"PEPSKit.renormalize_north_edge","text":"renormalize_north_edge((row, col), envs, P_left, P_right, ket, bra)\nrenormalize_north_edge(E_north, P_left, P_right, ket, bra)\n\nAbsorb a bra-ket pair into the north edge using the given projectors and environment tensors.\n\n       |~~~~~~| -- E_north -- |~~~~~~~| \n    -- |P_left|      ||       |P_right| --\n       |~~~~~~| == ket-bra == |~~~~~~~| \n\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.renormalize_northeast_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_northeast_corner","text":"renormalize_northeast_corner((row, col), enlarged_envs::CTMRGEnv, P_left, P_right)\n\nApply renormalize_corner to the enlarged northeast corner.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_northwest_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_northwest_corner","text":"renormalize_northwest_corner((row, col), enlarged_envs::CTMRGEnv, P_left, P_right)\n\nApply renormalize_corner to the enlarged northwest corner.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_south_edge","page":"Library","title":"PEPSKit.renormalize_south_edge","text":"renormalize_south_edge((row, col), envs, P_left, P_right, ket, bra)\nrenormalize_south_edge(E_south, P_left, P_right, ket, bra)\n\nAbsorb a bra-ket pair into the south edge using the given projectors and environment tensors.\n\n       |~~~~~~~| == ket-bra == |~~~~~~| \n    -- |P_right|      ||       |P_left| --\n       |~~~~~~~| -- E_south -- |~~~~~~| \n\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#PEPSKit.renormalize_southeast_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_southeast_corner","text":"renormalize_southeast_corner((row, col), enlarged_envs::CTMRGEnv, P_left, P_right)\n\nApply renormalize_corner to the enlarged southeast corner.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_southwest_corner-NTuple{4, Any}","page":"Library","title":"PEPSKit.renormalize_southwest_corner","text":"renormalize_southwest_corner((row, col), enlarged_envs::CTMRGEnv, P_left, P_right)\n\nApply renormalize_corner to the enlarged southwest corner.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_top_corner-Tuple{Any, CTMRGEnv, Any}","page":"Library","title":"PEPSKit.renormalize_top_corner","text":"renormalize_top_corner((row, col), envs::CTMRGEnv, projectors)\n\nApply top projector to northwest corner and north edge.\n\n     C -- E -- \n     |    ||\n    [~P_top~]\n        | \n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.renormalize_west_edge-Union{Tuple{Pb}, Tuple{Pt}, Tuple{Any, CTMRGEnv, Array{Pb, 3}, Array{Pt, 3}, InfinitePEPS}, Tuple{Any, CTMRGEnv, Array{Pb, 3}, Array{Pt, 3}, InfinitePEPS, InfinitePEPS}} where {Pt, Pb}","page":"Library","title":"PEPSKit.renormalize_west_edge","text":"renormalize_west_edge((row, col), envs, P_top, P_bottom, ket, bra)\nrenormalize_west_edge(E_west, P_top, P_bottom, ket, bra)\n\nAbsorb a bra-ket pair into the west edge using the given projectors and environment tensors.\n\n            |\n     [~~P_bottom~~]\n      |         ||\n    E_west == ket-bra\n      |         ||\n     [~~~~P_top~~~]\n            |\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.rotate_north-Tuple{Any, Any}","page":"Library","title":"PEPSKit.rotate_north","text":"rotate_north(t, dir)\n\nRotate north direction of t to dir by successive applications of rotl90.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.square_lattice_heisenberg-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Number","page":"Library","title":"PEPSKit.square_lattice_heisenberg","text":"square_lattice_heisenberg(::Type{T}=ComplexF64; Jx=-1, Jy=1, Jz=-1, unitcell=(1, 1))\n\nSquare lattice Heisenberg model. By default, this implements a single site unit cell via a sublattice rotation.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.square_lattice_j1j2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Number","page":"Library","title":"PEPSKit.square_lattice_j1j2","text":"square_lattice_j1j2(::Type{T}=ComplexF64; J1=1, J2=1, unitcell=(1, 1), sublattice=true)\n\nSquare lattice J₁-J₂ model. The sublattice kwarg enables a single site unit cell via a sublattice rotation.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.square_lattice_pwave-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Number","page":"Library","title":"PEPSKit.square_lattice_pwave","text":"square_lattice_pwave(::Type{T}=ComplexF64; t=1, μ=2, Δ=1, unitcell=(1, 1))\n\nSquare lattice p-wave superconductor model.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.square_lattice_tf_ising-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:Number","page":"Library","title":"PEPSKit.square_lattice_tf_ising","text":"square_lattice_tf_ising(::Type{T}=ComplexF64; J=1, h=1, unitcell=(1, 1))\n\nSquare lattice transverse field Ising model.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.symmetrize!-Tuple{InfinitePEPS, Nothing}","page":"Library","title":"PEPSKit.symmetrize!","text":"symmetrize!(peps::InfinitePEPS, ::SymmetrizationStyle)\n\nSymmetrize a PEPS using the given SymmetrizationStyle in-place.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.symmetrize_finalize!-Tuple{PEPSKit.SymmetrizationStyle}","page":"Library","title":"PEPSKit.symmetrize_finalize!","text":"symmetrize_finalize!(symm::SymmetrizationStyle)\n\nReturn finalize! function for symmetrizing the peps and grad tensors in-place, which maps (peps_symm, envs), E, grad_symm = symmetrize_finalize!((peps, envs), E, grad, numiter).\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TensorKit.tsvd-Tuple{TensorKit.AbstractTensorMap, Any}","page":"Library","title":"TensorKit.tsvd","text":"PEPSKit.tsvd(t::AbstractTensorMap, alg; trunc=notrunc(), p=2)\n\nWrapper around TensorKit.tsvd which dispatches on the alg argument. This is needed since a custom adjoint for PEPSKit.tsvd may be defined, depending on the algorithm. E.g., for IterSVD the adjoint for a truncated SVD from KrylovKit.svdsolve is used.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#PEPSKit.@autoopt-Tuple{Any}","page":"Library","title":"PEPSKit.@autoopt","text":"autoopt(ex)\n\nPreprocessor macro for @tensor which automatically inserts costs for all symbols that start with a pattern. In particular, all labels that start with d, D, or χ are automatically inserted with the corresponding costs.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.@diffset-Tuple{Any}","page":"Library","title":"PEPSKit.@diffset","text":"@diffset assign\n\nHelper macro which allows in-place operations in the forward-pass of Zygote, but resorts to non-mutating operations in the backwards-pass. The expression assign should assign an object to an pre-existing AbstractArray and the use of updating operators is also possible. This is especially needed when in-place assigning tensors to unit-cell arrays of environments.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.@fwdthreads-Tuple{Any}","page":"Library","title":"PEPSKit.@fwdthreads","text":"@fwdthreads(ex)\n\nApply Threads.@threads only in the forward pass of the program.\n\nIt works by wrapping the for-loop expression in an if statement where in the forward pass the loop in computed in parallel using Threads.@threads, whereas in the backwards pass the Threads.@threads is omitted in order to make the expression differentiable.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.@showtypeofgrad-Tuple{Any}","page":"Library","title":"PEPSKit.@showtypeofgrad","text":"@showtypeofgrad(x)\n\nMacro utility to show to type of the gradient that is about to accumulate for x.\n\nSee also Zygote.@showgrad.\n\n\n\n\n\n","category":"macro"},{"location":"lib/lib/#PEPSKit.Defaults","page":"Library","title":"PEPSKit.Defaults","text":"module Defaults\n    const ctmrg_maxiter = 100\n    const ctmrg_miniter = 4\n    const ctmrg_tol = 1e-12\n    const fpgrad_maxiter = 100\n    const fpgrad_tol = 1e-6\nend\n\nModule containing default values that represent typical algorithm parameters.\n\nctmrg_maxiter = 100: Maximal number of CTMRG iterations per run\nctmrg_miniter = 4: Minimal number of CTMRG carried out\nctmrg_tol = 1e-12: Tolerance checking singular value and norm convergence\nfpgrad_maxiter = 100: Maximal number of iterations for computing the CTMRG fixed-point gradient\nfpgrad_tol = 1e-6: Convergence tolerance for the fixed-point gradient iteration\n\n\n\n\n\n","category":"module"},{"location":"man/intro/","page":"Manual","title":"Manual","text":"Coming soon.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For now, refer to the examples folder on GitHub.","category":"page"},{"location":"#PEPSKit.jl","page":"Home","title":"PEPSKit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools for working with projected entangled-pair states","category":"page"},{"location":"","page":"Home","title":"Home","text":"It contracts, it optimizes, it may break.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed through the Julia general registry, via the package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add PEPSKit","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After following the installation process, it should now be possible to load the packages and start simulating. For example, in order to obtain the groundstate of the 2D Heisenberg model, we can use the following code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TensorKit, PEPSKit, KrylovKit, OptimKit\n\n# constructing the Hamiltonian:\nH = square_lattice_heisenberg(; Jx=-1, Jy=1, Jz=-1) # sublattice rotation to obtain single-site unit cell\n\n# configuring the parameters\nD = 2\nchi = 20\nctm_alg = CTMRG(; tol=1e-10, miniter=4, maxiter=100, verbosity=1, trscheme=truncdim(chi))\nopt_alg = PEPSOptimize(;\n    boundary_alg=ctm_alg,\n    optimizer=LBFGS(4; maxiter=100, gradtol=1e-4, verbosity=2),\n    gradient_alg=LinSolver(),\n    reuse_env=true,\n)\n\n# ground state search\nstate = InfinitePEPS(2, D)\nctm = leading_boundary(CTMRGEnv(state, ComplexSpace(chi)), state, ctm_alg)\nresult = fixedpoint(state, H, opt_alg, ctm)\n\n@show result.E # -0.6625...","category":"page"}]
}
